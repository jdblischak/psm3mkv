[{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"Copyright © 2023 Merck & Co., Inc., Rahway, NJ, USA and its affiliates. All rights reserved.  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example use of psm3mkv","text":"vignette walks evaluating partitioned survival model (PSM) state transition model structures (either clock reset, STM-CR, clock forward types, STM-CF) dataset derived bosms3 dataset comes [flexsurv::flexsurv-package()].[1] review PSMs STMs oncology cost-effectiveness models provided Woods et al.[2] First need load packages interest. haven’t installed psm3mkv yet, please see installation instructions install packages required run code .","code":"library(\"boot\") library(\"ggsci\") library(\"psm3mkv\") library(\"purrr\")"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"obtaining-a-suitable-dataset","dir":"Articles","previous_headings":"","what":"Obtaining a suitable dataset","title":"Example use of psm3mkv","text":"First create suitable patient-level dataset using create_dummydata(). load data derived bosms3 dataset flexsurv package.[2] dataset contains TTP, PFS OS data 204 patients.","code":"# Create and review the dummy dataset bosonc <- create_dummydata(\"flexbosms\") head(bosonc) #> # A tibble: 6 × 7 #>    ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag #>   <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl> #> 1     1   18.7          1   42.9        1   18.7          1 #> 2     2   12.0          1   23.3        1   12.0          1 #> 3     3    0.452        1    8.81       1    0.452        1 #> 4     4    9.07         1   52.7        1    9.07         1 #> 5     5   47.7          0   47.7        0   47.7          0 #> 6     6    3.26         1   13.1        1    3.26         1 summary(bosonc) #>       ptid           pfs.durn          pfs.flag         os.durn       #>  Min.   :  1.00   Min.   : 0.1071   Min.   :0.0000   Min.   : 0.881   #>  1st Qu.: 51.75   1st Qu.: 4.2381   1st Qu.:0.0000   1st Qu.: 7.893   #>  Median :102.50   Median : 9.7262   Median :1.0000   Median :15.226   #>  Mean   :102.50   Mean   :11.5630   Mean   :0.6471   Mean   :17.055   #>  3rd Qu.:153.25   3rd Qu.:16.2321   3rd Qu.:1.0000   3rd Qu.:22.729   #>  Max.   :204.00   Max.   :48.5357   Max.   :1.0000   Max.   :52.702   #>     os.flag          ttp.durn          ttp.flag      #>  Min.   :0.0000   Min.   : 0.1071   Min.   :0.0000   #>  1st Qu.:0.0000   1st Qu.: 4.2381   1st Qu.:0.0000   #>  Median :0.0000   Median : 9.7262   Median :1.0000   #>  Mean   :0.4755   Mean   :11.5630   Mean   :0.5049   #>  3rd Qu.:1.0000   3rd Qu.:16.2321   3rd Qu.:1.0000   #>  Max.   :1.0000   Max.   :48.5357   Max.   :1.0000"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"fit-survival-curves-to-the-relevant-endpoints","dir":"Articles","previous_headings":"","what":"Fit survival curves to the relevant endpoints","title":"Example use of psm3mkv","text":"three cost-effectiveness model structures considering rely modeling PFS, TTP OS, additionally three endpoints: pre-progression death (PPD), post progression survival function time baseline (known ‘clock forward’, PPS-CF), post-progression survival function time progression (known ‘clock reset’, PPS-CR). suitable dataset, fit statistical models six endpoints.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"parametric-distributions","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Parametric distributions","title":"Example use of psm3mkv","text":"Let us start considering parametric distributions. uses function fit_ends_mods_par(), called cycles fitting endpoints models. original dataset contained three endpoints, three endpoints calculated within function. fitted multiple parametric distributions endpoint. need retain best-fitting distribution, select using find_bestfit_par() basis distribution lowest Akaike Information Criterion (AIC).","code":"# Create a vector of distributions of interest (flexsurv notation) alldists <- c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\", \"gengamma\")  # Fit all distributions to all endpoints (except gengamma to PPD and TTP) allfits_par <- fit_ends_mods_par(bosonc,                             cuttime=0,                             ppd.dist=alldists[1:6],                             ttp.dist=alldists[1:6],                             pfs.dist=alldists,                             os.dist=alldists,                             pps_cf.dist=alldists,                             pps_cr.dist=alldists)  # Example 1 - PFS endpoint, distribution 2 (weibullPH) allfits_par$pfs[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.9313  0.8080  1.0733  0.0675 #> scale  0.0676  0.0453  0.1009  0.0138 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0729, df = 2 #> AIC = 1028.146  # Example 2 - Parameter values for PPS-CF and PPS-CR endpoints for distribution 3 (llogis) allfits_par$pps_cf[[3]]$result$res #>             est     L95%     U95%        se #> shape  1.625037 1.264658  2.08811 0.2078833 #> scale 12.184292 8.588947 17.28465 2.1737642 allfits_par$pps_cr[[3]]$result$res #>             est     L95%      U95%        se #> shape  1.602773 1.321696  1.943626 0.1576797 #> scale 11.031674 8.769443 13.877487 1.2917274 # Pick out best distribution according to min AIC fitpar.ppd <- find_bestfit_par(allfits_par$ppd, \"aic\") fitpar.ttp <- find_bestfit_par(allfits_par$ttp, \"aic\") fitpar.pfs <- find_bestfit_par(allfits_par$pfs, \"aic\") fitpar.os <- find_bestfit_par(allfits_par$os, \"aic\") fitpar.pps_cf <- find_bestfit_par(allfits_par$pps_cf, \"aic\") fitpar.pps_cr <- find_bestfit_par(allfits_par$pps_cr, \"aic\")  # Inspect the selection for PFS fitpar.pfs #> $fit #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.05596  0.04718  0.06637  0.00487 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.5726, df = 1 #> AIC = 1027.145 #>  #>  #> $results #> # A tibble: 7 × 11 #>      id dists      npts  pars loglik conv  posdef   aic   bic rankaic rankbic #>   <int> <chr>     <dbl> <dbl>  <dbl> <lgl> <lgl>  <dbl> <dbl>   <dbl>   <dbl> #> 1     1 exp         204     1  -513. TRUE  TRUE   1027. 1030.       1       1 #> 2     2 weibullPH   204     2  -512. TRUE  TRUE   1028. 1035.       3       3 #> 3     3 llogis      204     2  -513. TRUE  TRUE   1031. 1037.       6       5 #> 4     4 lnorm       204     2  -517. TRUE  TRUE   1038. 1044.       7       7 #> 5     5 gamma       204     2  -512. TRUE  TRUE   1028. 1035.       4       4 #> 6     6 gompertz    204     2  -512. TRUE  TRUE   1027. 1034.       2       2 #> 7     7 gengamma    204     3  -512. TRUE  TRUE   1030. 1040.       5       6"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"royston-parmar-splines-models","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Royston-Parmar splines models","title":"Example use of psm3mkv","text":"alternative approach parametric modeling use Royston-Parmar splines.[3] can follow similar approach, using flexsurv [2] identify best-fitting spline distributions. six endpoints, fit 9 spline models: 1, 2 3 (internal) knots either odds, hazard normal scales. uses fit_ends_mods_spl(). fitted multiple splines endpoint. need retain best-fitting distribution, select basis distribution lowest Akaike Information Criterion (AIC). use find_bestfit_spl() .","code":"# Fit 1-3 knot splines with all 3 scales (odds, hazard, normal) to each endpoint allfits_spl <- fit_ends_mods_spl(bosonc)  # Example - PFS endpoint - 1 knot, odds scale allfits_spl$pfs[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.84806  -3.29863  -2.39748   0.22989 #> gamma1   0.83234   0.44998   1.21469   0.19508 #> gamma2  -0.02545  -0.05136   0.00045   0.01322 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7148, df = 3 #> AIC = 1029.43 allfits_spl$pfs[[2]]$result$aux$scale # Scale #> [1] \"odds\" allfits_spl$pfs[[2]]$result$aux$knots # Knot locations (log time) #>                 50%            #> -2.233592  2.008522  3.882300 # Pick out best distribution according to min AIC fitspl.ppd <- find_bestfit_spl(allfits_spl$ppd, \"aic\") fitspl.ttp <- find_bestfit_spl(allfits_spl$ttp, \"aic\") fitspl.pfs <- find_bestfit_spl(allfits_spl$pfs, \"aic\") fitspl.os <- find_bestfit_spl(allfits_spl$os, \"aic\") fitspl.pps_cf <- find_bestfit_spl(allfits_spl$pps_cf, \"aic\") fitspl.pps_cr <- find_bestfit_spl(allfits_spl$pps_cr, \"aic\")  # Inspect the selection for PFS fitspl.pfs #> $fit #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.62401  -1.84681  -1.40122   0.11367 #> gamma1   0.37082   0.20155   0.54008   0.08636 #> gamma2  -0.02243  -0.03539  -0.00947   0.00661 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.4637, df = 3 #> AIC = 1028.927 #>  #>  #> $results #> # A tibble: 9 × 11 #>      id nknots scales  npts  pars loglik conv    aic   bic rankaic rankbic #>   <int>  <dbl> <chr>  <dbl> <dbl>  <dbl> <lgl> <dbl> <dbl>   <dbl>   <dbl> #> 1     1      1 hazard   204     3  -512. TRUE  1030. 1040.       5       3 #> 2     2      1 odds     204     3  -512. TRUE  1029. 1039.       2       2 #> 3     3      1 normal   204     3  -511. TRUE  1029. 1039.       1       1 #> 4     4      2 hazard   204     4  -512. TRUE  1032. 1045.       9       6 #> 5     5      2 odds     204     4  -511. TRUE  1031. 1044.       7       4 #> 6     6      2 normal   204     4  -511. TRUE  1031. 1044.       8       5 #> 7     7      3 hazard   204     5  -510. TRUE  1030. 1046.       3       7 #> 8     8      3 odds     204     5  -510. TRUE  1030. 1047.       6       9 #> 9     9      3 normal   204     5  -510. TRUE  1030. 1046.       4       8"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"combine-the-best-fits","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Combine the best fits","title":"Example use of psm3mkv","text":"Finally, select preferred curves endpoint. may may selected minimum AIC may parametric fits spline fits. list deliberately programmed manually - carefully. example use best fits case merely illustrates options available modeler. Let us count many parameters using model.","code":"# Bring together our preferred fits for each endpoint in a list params <- list(ppd = fitpar.ppd$fit,                ttp = fitpar.ttp$fit,                pfs = fitspl.pfs$fit,                os = fitspl.os$fit,                pps_cf = allfits_par$pps_cf[[2]]$result,                pps_cr = allfits_spl$pps_cr[[2]]$result                ) # Pull out number of parameters used for each endpoint count_npar <- map_vec(1:6, ~params[[.x]]$npars)  # PSM uses PFS (3) and OS (4) endpoints sum(count_npar[c(3,4)]) #> [1] 6  # STM_CF uses PPD (1), TTP (2) and PPS_CF (5) endpoints sum(count_npar[c(1,2,5)]) #> [1] 6  # STM_CR uses PPD (1), TTP (2) and PPS_CR (6) endpoints sum(count_npar[c(1,2,6)]) #> [1] 7"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"comparing-likelihood-values-for-the-three-model-structures","dir":"Articles","previous_headings":"","what":"Comparing likelihood values for the three model structures","title":"Example use of psm3mkv","text":"Given selected survival modeling endpoint, can now calculate compare (log-)likelihood three model structures. can also check output ensure number parameters used model structure matches derived earlier. case, model structures fitted 203 204 patients. Among 203 patients models fitted, STM-CR model greatest likelihood (best fitting) also lowest AIC (efficient). (Since nested models, statistical distributions null hypothesis easily formed, readily derive p-value statistical significance difference.)","code":"ll_all <- calc_likes(bosonc, params) ll_all #> $detailed #> # A tibble: 6 × 7 #>   valid outcome  npts   ll_1   ll_2   ll_3   ll_4 #>   <lgl>   <dbl> <int>  <dbl>  <dbl>  <dbl>  <dbl> #> 1 FALSE       4     1   NA     NA     NA     NA   #> 2 TRUE        1    72  -64.8  -64.8  -64.7  -64.7 #> 3 TRUE        2    29 -152.  -148.  -147.  -147.  #> 4 TRUE        3    35 -151.  -149.  -148.  -148.  #> 5 TRUE        4    67 -469.    NA     NA     NA   #> 6 TRUE        4    68   NA   -471.  -474.  -474.  #>  #> $valid #> # A tibble: 4 × 6 #>   methno methname    npts_TRUE npts_FALSE ll_TRUE ll_FALSE #>    <dbl> <chr>           <int>      <int>   <dbl>    <dbl> #> 1      1 psm_simple        203          1   -836.    NA    #> 2      2 psm_complex       203          1   -828.    -5.11 #> 3      3 stm_cf            203          1   -828.    -5.85 #> 4      4 stm_cr            203          1   -827.    -6.20 #>  #> $sumall #> # A tibble: 8 × 10 #>   validall methno methname     npts      ll nparam   aic   bic rank_aic rank_bic #>   <lgl>     <dbl> <chr>       <int>   <dbl>  <dbl> <dbl> <dbl>    <dbl>    <dbl> #> 1 FALSE         1 psm_simple      1   NA         7   NA    NA        NA       NA #> 2 FALSE         2 psm_complex     1   -5.11      8   NA    NA        NA       NA #> 3 FALSE         3 stm_cf          1   -5.85      6   NA    NA        NA       NA #> 4 FALSE         4 stm_cr          1   -6.20      7   NA    NA        NA       NA #> 5 TRUE          1 psm_simple    203 -836.        7 1685. 1709.        4        4 #> 6 TRUE          2 psm_complex   203 -828.        8 1672. 1698.        3        3 #> 7 TRUE          3 stm_cf        203 -828.        6 1667. 1687.        2        1 #> 8 TRUE          4 stm_cr        203 -827.        7 1667. 1690.        1        2"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"other-measures-of-goodness-of-fit","dir":"Articles","previous_headings":"","what":"Other measures of goodness of fit","title":"Example use of psm3mkv","text":"Brier score measure goodness fit survival model particular point time set patient time--event data. Originally developed measuring performance weather forecasting, metric since used applications. extension Brier score integral Brier score, ‘area curve’ measure concordance survival model given set patient time--event data. integral taken minimum maximum event censoring times dataset. Calculations provided SurvMetrics R package, can slow run (1 minute example).[4] psm3mkv package allows examination Integrated Brier Scores fit Overall Survival model structures. case, IBS calculation involved integrating times 1.18 52.70. PSM least IBS best fit (IBS=0.1771); two STMs slightly greater IBS values (0.1773 CF 0.1776 CR).","code":"# calc_ibs(bosonc, params)"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"comparing-the-implied-restricted-mean-durations","dir":"Articles","previous_headings":"","what":"Comparing the implied (restricted) mean durations","title":"Example use of psm3mkv","text":"order understand degree structural uncertainty (sensitivity choice model structure), calculate (restricted) mean durations progression-free (PF) progressed disease (PD) states model type. , call calc_allrmds() function dataset statistical distributions wish consider endpoint. function also allows specification patient subset use (inclset, important bootstrapping later) time horizon. units time horizon 52.18 times shorter units output - time horizon can considered units years, whereas output units weeks. two STMs estimate duration PF state slightly longer PSM. PSM also estimates least time PD state alive overall models. STM-CF provides longest estimate time PD state overall. output can bootstrapped generate standard errors. use just 10 boostrap samples (R=10) just illustrate process. practice, want use far 10 samples. Note percentiles information reported indicates small number samples, restricted mean duration PD restricted negative PSM. indicates inconsistency statistical models used case modeling PFS OS, may additional reason STMs may preferred case.","code":"# Call the RMD functions rmd_all <- calc_allrmds(bosonc, dpam=params)  # Then review the mean duration in PF, PD and total alive (OS) rmd_all$results #> # A tibble: 3 × 4 #>      pf    pd    os model  #>   <dbl> <dbl> <dbl> <chr>  #> 1  22.0  5.41  27.4 PSM    #> 2  20.0 10.4   30.4 STM-CF #> 3  20.0 13.3   33.3 STM-CR"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"visual-inspection-of-model-fits","dir":"Articles","previous_headings":"","what":"Visual inspection of model fits","title":"Example use of psm3mkv","text":"Creating four graphics model fit straightforward. can compare state membership probabilities PF PD states.  PF curves fully overlap observed period, appear fit well visually observed PF data.  big differences fit models PD membership probability. best visual fit comes PSM. STMs estimate higher probability PD membership later times observed. highest probabilities STM-CF model. Next, can look probabilities alive (.e: membership either PF PD state).  , three models fit fairly well 15 weeks. closest visual fit OS curve PSM. surprising PSM involves fitting OS endpoint directly. Following PD membership graphics, STMs appear -estimate OS longer durations relative observed data. However, recall overall PSM worse fit data according likelihood, AIC BIC. Finally can look probabilities post-progression survival. observed fitted STMs PSM. STM-CR estimate follows directly fitted PPS-CR survival curve. STM-CF estimate derived based average, across patients, patients’ expected PPS-CF survival relative TTP timepoint.","code":"# Generate graphs (can take time) ptdgraphs <- graph_survs(bosonc, params) #> Creating KM  #> Calculating fitted curves  #> Rearranging datasets  #> Drawing plots # State membership probabilities for PF state ptdgraphs$graph$pf + scale_color_npg() #> Warning: Removed 5 rows containing missing values or values outside the scale range #> (`geom_line()`). # State membership probabilities for PD state ptdgraphs$graph$pd + scale_color_npg() #> Warning: Removed 5 rows containing missing values or values outside the scale range #> (`geom_line()`). # State membership probabilities for OS ptdgraphs$graph$os + scale_color_npg() #> Warning: Removed 5 rows containing missing values or values outside the scale range #> (`geom_line()`). # Probabilities of PPS ptdgraphs$graph$pps + scale_color_npg() #> Warning: Removed 85 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Example use of psm3mkv","text":"Jackson C, Metcalfe P, Amdahl J, Warkentin MT, Sweeting M, Kunzmann K. flexsurv: Flexible Parametric Survival Multi-State Models. Available : https://cran.r-project.org/package=flexsurv. Woods BS, Sideris E, Palmer S, Latimer N, Soares M. Partitioned Survival State Transition Models Healthcare Decision Making Oncology: Now? Value Health 23(12):1613-21; 2020. DOI: 10.1016/j.jval.2020.08.2094 Royston P Parmar M. Flexible parametric proportional-hazards proportional-odds models censored survival data, application prognostic modelling estimation treatment effects. Statistics Medicine 21(1):2175-2197; 2002. DOI: 10.1002/sim.1203 Hanpu Z. Predictive Evaluation Metrics Survival Analysis. Vignette SurvMetrics R package. July 2021. Available : https://cran.r-project.org/package=SurvMetrics/vignettes/SurvMetrics-vignette.html","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Mortality adjustments","text":"second series vignettes illustrating methods evaluating fit efficiency three state oncology cost-effectiveness model structures, described accompanying journal article.[1] package heavily dependent flexsurv).[2] fitting models, described vignette(\"example\"), estimates Restricted Mean Durations (RMDs) health states can calculated constraining background mortality given life table.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"notation","dir":"Articles","previous_headings":"Introduction","what":"Notation","title":"Mortality adjustments","text":"denote functions survival, hazard cumulative hazard \\(S(t), h(t)\\) \\(H(t)\\). ‘unadjusted’ values relevant endpoints (e.g. PFS) dependent model structure (PSM, STM-CF STM-CR). assume ‘general background mortality’, extrapolations derivations RMD constrained, denoted subscript ‘gen’. Consequently ‘adjusted’ values, denoted superscript ‘adj’.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"background-mortality-survival-and-hazard-functions","dir":"Articles","previous_headings":"Introduction","what":"Background mortality survival and hazard functions","title":"Mortality adjustments","text":"lifetable gives us decreasing \\(l_x\\) values points \\(t=0, ..., t_{max}\\), \\(l_{t_{max}}=0\\). Let us define background mortality survival function follows. \\[ S_{gen}(t) = 1 - R \\left(1 - \\frac{l_{x_0 + t}}{l_{x_0}} \\right) \\] \\(x_0\\) mean age study population baseline, \\(l_x\\) appropriate lifetable. can also derive average background mortality hazard \\(t\\) range \\([t_1, t_2)\\). \\[ h_{gen}(t) = \\frac{\\log[S_{gen}(t_1)] - \\log[S_{gen}(t_2)]}{t_2 - t_1} \\]","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"what-does-constraining-for-background-mortality-mean","dir":"Articles","previous_headings":"","what":"What does constraining for background mortality mean?","title":"Mortality adjustments","text":"number approaches applied literature HTA submissions, mean several things!","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-1---constraining-only-the-survival-function","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 1 - Constraining only the survival function","title":"Mortality adjustments","text":"approach, background mortality assumed limit survival function follows. direct constraint hazard. \\[ S^{adj}(t) = \\min \\left[ S(t), S_{gen}(t) \\right] \\] simple approach, used least one NICE technology appraisal: “Patient longevity always lesser values generated disease-specific survival curve (adjustment treatment functional status) survival curve general population according age sex.”[3] However, approach ensure hazard least great hazard background mortality.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-2---constraining-the-hazard-function","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 2 - Constraining the hazard function","title":"Mortality adjustments","text":"rigorous adjustment hazard background mortality acts constraint unadjusted hazard.[4] \\[ h^{adj}(t) = \\max \\left[ h(t), h_{gen}(t) \\right] \\] \\[ \\implies S^{adj}(t) = \\exp \\left[ - \\int_0^t h^{adj}(u) du \\right] \\] either case, must assume original dataset subject background mortality. Although unlikely true, common, pragmatic assumption cost-effectiveness models long background mortality relatively insignificant trial follow-.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-3---modeling-excess-hazard-in-the-original-dataset","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 3 - Modeling excess hazard in the original dataset","title":"Mortality adjustments","text":"approaches work adjusting extrapolations made models fitted data assumed subject background mortality. - likely - population dataset fact subject background mortality, better model dataset using excess hazard methods rather seek make adjustments extrapolations fact. discussion survival extrapolation incorporating general population mortality provided Sweeting et al.[4]","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"application-to-3-state-state-transition-models-stms","dir":"Articles","previous_headings":"","what":"Application to 3-state State Transition Models (STMs)","title":"Mortality adjustments","text":"discussed previously, state transition models three states may clock forward (‘STM-CF’) ‘clock reset’ (STM-CR). structures involve modeling transition directly, may performed fitting survival distributions TTP, PPD PPS endpoints. general, wish constrain pre- post-progression mortality (PPD PPS) least great background mortality. \\[ h^{adj}_{PPD}(t) = \\max \\left[h_{gen}(t), h_{PPD}(t) \\right] \\\\ h^{adj}_{PPS}(t) = \\max \\left[h_{gen}(t), h_{PPS}(t) \\right] \\\\ \\] Formulas mean time PF OS shown accompanying article respect hazard survival functions TTP, PPD PPS endpoints, PPS function time baseline Clock Forward (CF) time progression Clock Reset (CR) model. Adjusting background mortality requires using adjusted rather unadjusted hazards PPD PPS formulae. straightforward enough PPD endpoint STM-CF STM-CR structures, PPS endpoint STM-CF structure. However matters complex PPS endpoint STM-CF since hazard survival functions two times (time progression time baseline) rather just one (time baseline). package provide integral solutions relying continuous time RMDs, must instead rely discretization. Spreadsheet-based economic models almost always rely discretizing time timesteps rather follow integral formulas described continuous time. long timesteps reasonably short, restricted mean duration results remain reasonably accurate. Derided “kludge”, half-cycle corrections nevertheless recommended.[5] package provides discretized calculations.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"application-to-partitioned-survival-models-psm","dir":"Articles","previous_headings":"","what":"Application to Partitioned Survival Models (PSM)","title":"Mortality adjustments","text":"RMD PF state time alive integrals time horizon, \\(T\\), survival functions endpoints PFS OS. Endpoints PPD PPS explicitly defined. However discussed accompanying manuscript, TTP - therefore PPD PPS endpoints directly follow PFS OS defined - often practice implicitly defined PSM economic model order calculate payoffs depend progression events. Two methods possible: Simple (default): hazard TTP relative PFS proportionate progression events observed follow-period relative total number observed PFS events. Complex: hazard TTP directly modeled fitting survival distributions endpoints. adjustment RMD estimates can proceed STMs, hazards survival functions TTP, PPD PPS reflect PSM structure (PFS OS endpoints first estimated), chosen model progression (simple complex), finally adjustment PPD PPS background mortality.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"set-up","dir":"Articles","previous_headings":"Illustration of calculations","what":"Set-up","title":"Mortality adjustments","text":"First load packages need - suggested imported psm3mkv. haven’t installed psm3mkv yet, please see installation instructions install packages required run code .","code":"library(\"dplyr\") library(\"HMDHFDplus\") library(\"psm3mkv\") library(\"tibble\")"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"creating-the-life-table","dir":"Articles","previous_headings":"Illustration of calculations","what":"Creating the life table","title":"Mortality adjustments","text":"order apply constraints background mortality, need background mortality data, form lifetable. can take Human Mortality Database using HMDHFDplus package mentioned (thanks Robert Hettle recommendation). lifetable need start assumed age baseline. Lifetables constructed time years. see code run without login Human Mortality Database. Alternatively, just make mortality table. However , mortality data, can apply SMR (\\(R\\)) derive lifetable time zero required.","code":"# Assumed population age at baseline (time=0) baseage <- 51.0  # Mortality data - England & Wales, Female, 2019 mort <- readHMDweb(CNTRY=\"GBRTENW\",                         item=\"fltper_1x1\",                         username=\"\",                         password=\"\"                         ) |>               filter(Year==2019) |>               select(Age, lx, dx) |>               mutate(Timey = ceiling(Age-baseage)) |>               filter(Timey>=0)  # The table needs to end with lx=0 mort <- add_row(mort, Age=111, lx=0, Timey=60) mort <- tibble(   Timey = 0:30,   lx = 10000 * exp(-0.03 * Timey^1.1),   dx = lx - lead(lx),   qx = dx/lx   ) # Assumed Standardized Mortality Ratio SMR <- 2  # Recalculate the lifetable with the SMR applied mort$adjlx <- mort$lx for (i in 2:length(mort$lx)) {   mort$adjlx[i] <- mort$adjlx[i-1] * (1 - SMR * mort$qx[i-1]) }  # Ensure lx>=0 mort$adjlx[mort$adjlx<0] <- 0  # Create and view lifetable ltable <- tibble(lttime=mort$Timey, lx=mort$adjlx) head(ltable) #> # A tibble: 6 × 2 #>   lttime     lx #>    <int>  <dbl> #> 1      0 10000  #> 2      1  9409. #> 3      2  8774. #> 4      3  8151. #> 5      4  7553. #> 6      5  6985."},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"obtaining-and-fitting-distributions-to-patient-level-data","dir":"Articles","previous_headings":"Illustration of calculations","what":"Obtaining and fitting distributions to patient-level data","title":"Mortality adjustments","text":"Next get patient-level data fit PSM STMs. far, closely following vignette(\"example\"). Time assumed recorded patient-level data weeks, approximately 52.18 weeks per year.","code":"# Get some data bosonc <- create_dummydata(\"flexbosms\")  # We'll make the durations a lot longer # so that they will be definitely constrained by the lifetable bosonc <- bosonc |>   mutate(     pfs.durn = 20 * pfs.durn,     os.durn = 20 * os.durn,     ttp.durn = 20 * ttp.durn   )  # Fit Royston Parmar splines models to each endpoint allfits <- fit_ends_mods_par(bosonc)  # Pick out best distributions according to min AIC fit.ppd <- find_bestfit_par(allfits$ppd, \"aic\") fit.ttp <- find_bestfit_par(allfits$ttp, \"aic\") fit.pfs <- find_bestfit_par(allfits$pfs, \"aic\") fit.os <- find_bestfit_par(allfits$os, \"aic\") fit.pps_cf <- find_bestfit_par(allfits$pps_cf, \"aic\") fit.pps_cr <- find_bestfit_par(allfits$pps_cr, \"aic\")  # Bring together our preferred fits for each endpoint in a list params <- list(ppd = fit.ppd$fit,                ttp = fit.ttp$fit,                pfs = fit.pfs$fit,                os = fit.os$fit,                pps_cf = fit.pps_cf$fit,                pps_cr = fit.pps_cr$fit                )"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"making-the-projections","dir":"Articles","previous_headings":"Illustration of calculations","what":"Making the projections","title":"Mortality adjustments","text":"skipping internal external validation purposes vignette, jump instead straight making survival projections. assume 10 year time horizon. First derive projection using integral formulae, without lifetable constraints. Next derive projection using discretization approximation, still without lifetable constraints. Discretization proven fairly accurate. STM-CR estimate mean time alive reduced just -0.1 weeks example, 393.9 394 weeks. Finally, use discretization approximation apply lifetable constraints. now large difference STM-CR compared STM-CF PSM structures. structures estimate fairly similar RMD estimates alive (range: 338.4 366.1 weeks). estimate mean time alive STM-CR structure reduced 52.4 weeks 393.9 341.6 weeks. proportion time PF rather PD state varies considerably (PSM: 74.9%, STM-CF: 68.1%, STM-CR: 67.5%). Given hazard mortality typically lower rather progression, pre-progression mortality likely affected mortality constraint post-progression mortality. STM-CR model post-progression survival depends time progression therefore rather different STM-CF PSM structures, model mortality based time baseline. can check whether using ‘complex’ type PSM structure rather default ‘simple’ affects RMD estimates PSM structure. structures estimate fairly similar RMD estimates alive (range: 338.4 366.1 weeks). proportion time PF rather PD state varied considerably model structure (PSM: 74.5%, STM-CF: 68.1%, STM-CR: 67.5%).","code":"# Set time horizon thoz <- 10  # Run the calculations proj1 <- calc_allrmds(bosonc, dpam=params, Ty=thoz)  # Present the results res1 <- proj1$results |> mutate(method=\"int\", lxadj=\"no\", psmmeth=\"simple\") res1 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1))) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     274.4     118.3     392.7 PSM    int    no    simple  #> 2     270.2     119.7     389.9 STM-CF int    no    simple  #> 3     270.2     123.8     393.9 STM-CR int    no    simple # Run the calculation proj2 <- calc_allrmds(bosonc, dpam=params, Ty=thoz, rmdmethod=\"disc\")  # Present the results res2 <- proj2$results |>   mutate(method=\"disc\", lxadj=\"no\", psmmeth=\"simple\") res2 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1))) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     274.2     118.5     392.7 PSM    disc   no    simple  #> 2     270.2     120.1     390.3 STM-CF disc   no    simple  #> 3     270.2     123.8     394.0 STM-CR disc   no    simple # Run the calculations proj3 <- calc_allrmds(bosonc, dpam=params, Ty=thoz, rmdmethod=\"disc\", lifetable=ltable)  # Present the results res3 <- proj3$results |>   mutate(method=\"disc\", lxadj=\"yes\", psmmeth=\"simple\") res3 |> mutate(     across(c(pf, pd, os), ~ num(.x, digits = 1))) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     274.2      91.9     366.1 PSM    disc   yes   simple  #> 2     230.4     108.0     338.4 STM-CF disc   yes   simple  #> 3     230.4     111.2     341.6 STM-CR disc   yes   simple  # Proportion of time alive spent in PF proppf3 <- res3$pf/res3$os # Run the calculations proj4 <- calc_allrmds(bosonc, dpam=params, Ty=thoz, psmtype=\"complex\", rmdmethod=\"disc\", lifetable=ltable)  # Present the results res4 <- proj4$results |>   mutate(method=\"disc\", lxadj=\"yes\", psmmeth=\"complex\") res4 |> mutate(     across(c(pf, pd, os), ~ num(.x, digits = 1))) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     272.9      93.2     366.1 PSM    disc   yes   complex #> 2     230.4     108.0     338.4 STM-CF disc   yes   complex #> 3     230.4     111.2     341.6 STM-CR disc   yes   complex  # Proportion of time alive spent in PF proppf4 <- res4$pf/res4$os"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"comparing-the-results","dir":"Articles","previous_headings":"Illustration of calculations","what":"Comparing the results","title":"Mortality adjustments","text":"summary STM-CF estimates mean time PF state mean time alive given table . fictional case, application lifetable constraint fairly sizeable effects results - although design demonstration. summary STM-CR estimates mean time PF state mean time alive given table . application lifetable constraint similar fairly sizeable effects results also. summary PSM estimates mean time PF state mean time alive given table . change RMDs ‘complex’ PSM structure compared ‘simple’ PSM structure -1.3, 1.3 0 weeks respectively time PF state, PD state time alive.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"for-further-investigation","dir":"Articles","previous_headings":"Illustration of calculations","what":"For further investigation","title":"Mortality adjustments","text":"effect lifetable constraint STMs much greater - especially time PF state - STMs rathe rather PSM. package also allows application discounting discrate optional call calc_allrnds().","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Mortality adjustments","text":"Muston D. Informing structural assumptions three state oncology cost-effectiveness models model efficiency fit. review. Jackson C, Metcalfe P, Amdahl J, Warkentin MT, Sweeting M, Kunzmann K. flexsurv: Flexible Parametric Survival Multi-State Models. Available : https://cran.r-project.org/package=flexsurv. National Institute Health Care Excellence. Avalglucosidase alfa treating Pompe disease. Technology appraisal guidance [TA821]. August 24, 2022. Available : https://www.nice.org.uk/guidance/ta821/documents/committee-papers Sweeting et al. Survival Extrapolation Incorporating General Population Mortality Using Excess Hazard Cure Models: Tutorial. Med Decis Making 2023 Aug;43(6):737-748. DOI: 10.1177/0272989X231184247 Naimark DMJ, Kabboul NN, Krahn MD. half-cycle correction revisited: redemption kludge. Medical Decision Making 2013; 33(7):961-70. DOI: 10.1177/0272989X13501558.","code":""},{"path":"https://merck.github.io/psm3mkv/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dominic Muston. Author, maintainer. Merck & Co., Inc.. Copyright holder, funder.","code":""},{"path":"https://merck.github.io/psm3mkv/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Muston D (2024). psm3mkv: Fit Evaluate Three-State Partitioned Survival Analysis Markov Models Progression-Free Overall Survival Data. R package version 0.2.1.9000, https://github.com/Merck/psm3mkv, https://merck.github.io/psm3mkv/.","code":"@Manual{,   title = {psm3mkv: Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data},   author = {Dominic Muston},   year = {2024},   note = {R package version 0.2.1.9000, https://github.com/Merck/psm3mkv},   url = {https://merck.github.io/psm3mkv/}, }"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"psm3mkv-a-package-to-evaluate-the-fit-and-efficiency-of-three-state-oncology-cost-effectiveness-model-structures-","dir":"","previous_headings":"","what":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"goal psm3mkv evaluate efficiency fit certain three state model structures data typical oncology clinical trial. package evaluates following structures: Partitioned Survival Model/analysis (PSM), Clock-forward State Transition Model (STM-CF), Clock-reset State Transition Model (STM-CR). state transition models differ transition progressive disease death function time baseline STM-CF time progression STM-CR.[1,2] package requires patient-level dataset time progression (TTP), progression-free survival (PFS) overall survival (OS). Given , package enables: Fitting range models endpoints relevant model type: One piece parametric (distributions according flexsurv). Royston-Parmar splines (1-3 internal knots, hazard/odds/normal scales, per flexsurv)[3]. Two piece parametric (given time cutoff). Selecting ‘best fit’ survival models endpoint (using Akaike Information Criterion, Bayesian Information Criterion user preference). Deriving presenting likelihoods 3 structures evaluate fit. Presenting total number parameters used structure, additionally evaluate efficiency. Deriving presenting restricted mean durations health state 3 model structures (given time horizon), evaluate plausibility structural sensitivity. Additional functionality: Constraining estimates ensure survival greater survival background lifetable. Applying discounting obtained discounted restricted means. Bootstrap standard errors can derived. Graphically illustrate observed fitted membership probabilities, allow visual inspection fit 3 model structures. two piece modeling used, modelers advised take care interpretation validity case different cutoff points selected different endpoints. Additionally, parametric modeling STM structures, model survival progressive disease state (post progression survival, PPS) may function additional arbitrary explanatory variable. intended enable exploration TTP (transformation) predictor PPS.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"accompanying vignette(\"example\") illustrates package can used one-piece parametric spline modeling. second vignette, vignette(\"background-mortality\") illustrates , fitting models, estimates restricted mean durations health states can calculated constraining background mortality given life table. Survival assumed greater background lifetable.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"package requires version 4.1 R (due use native pipe). Please ensure R updated first.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"latest-stable-release","dir":"","previous_headings":"Installation","what":"Latest stable release","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"Install latest stable release GitHub: Note pak::pak() build vignettes default installing package GitHub, ideal vignettes can take long time generate. can conveniently view package webpage.","code":"# install.packages(\"pak\") pak::pak(\"Merck/psm3mkv@*release\")"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"development-version","dir":"","previous_headings":"Installation","what":"Development version","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"Install latest development version GitHub (may stable):","code":"pak::pak(\"Merck/psm3mkv@main\")"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"additional-dependencies","dir":"","previous_headings":"Installation","what":"Additional dependencies","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"Running vignettes requires additional dependencies, either imported suggested psm3mkv. Thus can ensure installed specifying dependencies = TRUE.","code":"pak::pak(\"Merck/psm3mkv@*release\", dependencies = TRUE)"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"licensing","dir":"","previous_headings":"","what":"Licensing","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"Copyright (c) 2023 Merck & Co., Inc., Rahway, NJ, USA affiliates. rights reserved. file part psm3mkv program. psm3mkv free software: can redistribute /modify terms GNU General Public License published Free Software Foundation, either version 3 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. received copy GNU General Public License along program. , see http://www.gnu.org/licenses/. psm3mkv uses third-party R packages may distributed different licenses.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data","text":"Jackson C, Metcalfe P, Amdahl J, Warkentin MT, Sweeting M, Kunzmann K. flexsurv: Flexible Parametric Survival Multi-State Models. Available : https://cran.r-project.org/package=flexsurv. Woods BS, Sideris E, Palmer S, Latimer N, Soares M. Partitioned Survival State Transition Models Healthcare Decision Making Oncology: Now? Value Health 23(12):1613-21; 2020. DOI: 10.1016/j.jval.2020.08.2094 Royston P Parmar M. Flexible parametric proportional-hazards proportional-odds models censored survival data, application prognostic modelling estimation treatment effects. Statistics Medicine 21(1):2175-2197; 2002. DOI: 10.1002/sim.1203","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"Calculate restricted mean durations health state (progression free progressed disease) three models (partitioned survival, clock forward state transition model, clock reset state transition model).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"","code":"calc_allrmds(   ptdata,   inclset = 0,   dpam,   psmtype = \"simple\",   cuttime = 0,   Ty = 10,   lifetable = NA,   discrate = 0,   rmdmethod = \"int\",   timestep = 1 )"},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). inclset Vector indicate patients include analysis dpam List statistical fits endpoint required PSM, STM-CF STM-CR models. psmtype Either \"simple\" \"complex\" PSM formulation cuttime Time cutoff - nonzero two-piece models. Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. lifetable Optional, life table. Columns must include lttime (time years, 52.18 times shorter time index elsewhere, starting zero) lx discrate Discount rate (% per year) rmdmethod can \"int\" (default full integral calculations) \"disc\" approximate discretized calculations timestep required method==\"int\", default 1","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"List detailed numeric results cutadj indicates survival function area curves PFS OS cutpoint results provides results restricted means calculations, model state.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) # RMD using default \"int\" method, no lifetable constraint calc_allrmds(bosonc, dpam=params) #> $cutadj #> $cutadj$pfarea #> [1] 0 #>  #> $cutadj$pfsurv #> [1] 1 #>  #> $cutadj$osarea #> [1] 0 #>  #> $cutadj$ossurv #> [1] 1 #>  #>  #> $results #> # A tibble: 3 × 4 #>      pf    pd    os model  #>   <dbl> <dbl> <dbl> <chr>  #> 1  22.0  5.41  27.4 PSM    #> 2  19.0 10.5   29.5 STM-CF #> 3  19.0 11.1   30.0 STM-CR #>  # RMD using discretized (\"disc\") method, no lifetable constraint calc_allrmds(bosonc, dpam=params, rmdmethod=\"disc\", timestep=1) #> $cutadj #> $cutadj$pfarea #> [1] 0 #>  #> $cutadj$pfsurv #> [1] 1 #>  #> $cutadj$osarea #> [1] 0 #>  #> $cutadj$ossurv #> [1] 1 #>  #>  #> $results #> # A tibble: 3 × 4 #>      pf    pd    os model  #>   <dbl> <dbl> <dbl> <chr>  #> 1  18.4  8.82  27.2 PSM    #> 2  19.0 10.9   29.8 STM-CF #> 3  19.0 11.1   30.0 STM-CR #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","title":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","text":"Wrapper function calc_allrmds enable bootstrap sampling calculations restricted mean durations health state (progression free progressed disease) three models (partitioned survival, clock forward state transition model, clock reset state transition model).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","text":"","code":"calc_allrmds_boot(   ptdata,   inclset = 0,   dpam,   cuttime = 0,   Ty = 10,   lifetable = NA,   discrate = 0 )"},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). inclset Vector indicate patients include analysis dpam List statistical fits endpoint required PSM, STM-CF STM-CR models. cuttime Time cutoff - nonzero two-piece models. Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. lifetable Optional, life table. Columns must include lttime (time years, 52.18 times shorter time index elsewhere, starting zero) lx discrate Discount rate (% per year)","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds_boot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","text":"Numeric vector restricted mean durations - PF model (PSM, STM-CF, STM-CR), PD, OS.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds_boot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper to enable bootstrap sampling of restricted mean durations for each health state and all three models. — calc_allrmds_boot","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) calc_allrmds_boot(ptdata=bosonc, dpam=params) #> [1] 22.02965 18.97163 18.97163  5.41287 10.53941 11.05169 27.44252 29.51104 #> [9] 30.02332"},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the value of the density function — calc_dens","title":"Calculate the value of the density function — calc_dens","text":"Calculate value density function, given specification either parametric Royston-Parmar splines model","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the value of the density function — calc_dens","text":"","code":"calc_dens(time, type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the value of the density function — calc_dens","text":"time time distribution function calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the value of the density function — calc_dens","text":"value hazard function, numeric value.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the value of the density function — calc_dens","text":"","code":"calc_dens(time=1:5,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 0 0 0 0 0 calc_dens(time=1:5,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 0.004431848 0.013941703 0.021814325 0.027126183 0.030342439"},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the value of the density function (parametric form) — calc_dens_par","title":"Calculate the value of the density function (parametric form) — calc_dens_par","text":"Calculate value density function, given statistical distribution parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the value of the density function (parametric form) — calc_dens_par","text":"","code":"calc_dens_par(time, dist, pars)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the value of the density function (parametric form) — calc_dens_par","text":"time time distribution function calculated. dist statistical distribution (named per flexsurv::flexsurvreg). pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the value of the density function (parametric form) — calc_dens_par","text":"value density function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_dens_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the value of the density function (parametric form) — calc_dens_par","text":"","code":"calc_dens_par(10, \"exp\", 0.01) #> [1] 0.009048374 calc_dens_par(5, \"lnorm\", c(3, 1)) #> [1] 0.03034244"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ex.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted life expectancy from a lifetable — calc_ex","title":"Calculate restricted life expectancy from a lifetable — calc_ex","text":"Calculate restricted life expectancy lifetable","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted life expectancy from a lifetable — calc_ex","text":"","code":"calc_ex(Ty = 10, lifetable, discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted life expectancy from a lifetable — calc_ex","text":"Ty Time duration calculate (default 10 years). Assumes input years, patient-level data recorded weeks. lifetable lifetable must dataframe columns named lttime (years) lx. first entry time column must zero. Data sorted ascending order time, times must unique. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted life expectancy from a lifetable — calc_ex","text":"List containing ex_y ex_w', numeric (restricted) life expectancy years weeks respectively, calcs, dataframe calculations.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted life expectancy from a lifetable — calc_ex","text":"","code":"# Create a lifetable. Must end with lx=0. # ltable <- tibble::tibble(lttime=0:20, lx=1-lttime*0.05) # calc_ex(lifetable=ltable, discrate=0.03) # calc_ex(Ty=Inf, lifetable=ltable)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the value of the hazard function — calc_haz","title":"Calculate the value of the hazard function — calc_haz","text":"Calculate value hazard function, given specification either parametric Royston-Parmar splines model","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the value of the hazard function — calc_haz","text":"","code":"calc_haz(time, type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the value of the hazard function — calc_haz","text":"time time distribution function calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the value of the hazard function — calc_haz","text":"value hazard function, numeric value.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the value of the hazard function — calc_haz","text":"","code":"calc_haz(time=1:5,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 0 0 0 0 0 calc_haz(time=1:5,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 0.004437839 0.014090094 0.022457175 0.028653278 0.033059217"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the value of the hazard function (parametric form) — calc_haz_par","title":"Calculate the value of the hazard function (parametric form) — calc_haz_par","text":"Calculate value hazard function, given statistical distribution parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the value of the hazard function (parametric form) — calc_haz_par","text":"","code":"calc_haz_par(time, dist, pars)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the value of the hazard function (parametric form) — calc_haz_par","text":"time time distribution function calculated. dist statistical distribution (named per flexsurv::flexsurvreg). pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the value of the hazard function (parametric form) — calc_haz_par","text":"value hazard function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the value of the hazard function (parametric form) — calc_haz_par","text":"","code":"calc_haz_par(10, \"exp\", 0.01) #> [1] 0.01 calc_haz_par(5, \"lnorm\", c(3, 1)) #> [1] 0.03305922"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"Derive hazards death pre- post-progression either simple complex PSM formulations.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"","code":"calc_haz_psm(timevar, ptdata, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"timevar Vector times calculate hazards ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"List pre, pre-progression hazard, post, post-progression hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype=\"simple\") #> $adj #> $adj$ttp #>  [1] 0.00000000 0.04742078 0.04722152 0.04707233 0.04682576 0.04650723 #>  [7] 0.04614387 0.04575442 0.04533051 0.04479742 0.04418546 #>  #> $adj$ppd #>  [1] 0.000000000 0.009903692 0.013295380 0.013253374 0.013183952 0.013094269 #>  [7] 0.012991963 0.012882314 0.012762960 0.012612865 0.012440568 #>  #> $adj$pfs #>  [1] 0.00000000 0.05732447 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $adj$os #>  [1] 0.000000000 0.009300758 0.012253823 0.014430772 0.016195615 0.017678549 #>  [7] 0.018943502 0.020027650 0.020955175 0.021743175 0.022404577 #>  #> $adj$pps #>  [1] 0.000000000 0.000000000 0.005094092 0.024838109 0.034454269 0.040318847 #>  [7] 0.044430336 0.047603965 0.050244788 0.052614795 0.054815057 #>  #>  #> $unadj #> $unadj$ttp #>  [1] 0.00000000 0.04742078 0.04722152 0.04707233 0.04682576 0.04650723 #>  [7] 0.04614387 0.04575442 0.04533051 0.04479742 0.04418546 #>  #> $unadj$ppd #>  [1] 0.00000000 0.01335148 0.01329538 0.01325337 0.01318395 0.01309427 #>  [7] 0.01299196 0.01288231 0.01276296 0.01261286 0.01244057 #>  #> $unadj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $unadj$os #>  [1] 0.000000000 0.009363175 0.012472587 0.014891286 0.016981265 0.018871673 #>  [7] 0.020625521 0.022278934 0.023854812 0.025368713 0.026831756 #>  #> $unadj$pps #>  [1]         NaN 0.000000000 0.005094092 0.024838109 0.034454269 0.040318847 #>  [7] 0.044430336 0.047603965 0.050244788 0.052614795 0.054815057 #>  #>  calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype=\"complex\") #> $adj #> $adj$ttp #>  [1] 0.00000000 0.05758869 0.05337416 0.05075486 0.04878425 0.04717919 #>  [7] 0.04581438 0.04459666 0.04337732 0.04216807 0.04098853 #>  #> $adj$ppd #>  [1] 0.000000000 0.003183577 0.007142746 0.009570846 0.011225462 0.012422312 #>  [7] 0.013321453 0.014040074 0.014716157 0.015242215 0.015637501 #>  #> $adj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $adj$os #>  [1] 0.000000000 0.009300758 0.012253823 0.014430772 0.016195615 0.017678549 #>  [7] 0.018943502 0.020027650 0.020955175 0.021743175 0.022404577 #>  #> $adj$pps #>  [1] 0.00000000 0.11640992 0.06026855 0.04720160 0.04346609 0.04281332 #>  [7] 0.04340284 0.04448366 0.04559770 0.04699859 0.04859870 #>  #>  #> $unadj #> $unadj$ttp #>  [1] 0.00000000 0.05758869 0.05337416 0.05075486 0.04878425 0.04717919 #>  [7] 0.04581438 0.04459666 0.04337732 0.04216807 0.04098853 #>  #> $unadj$ppd #>  [1] 0.000000000 0.003183577 0.007142746 0.009570846 0.011225462 0.012422312 #>  [7] 0.013321453 0.014040074 0.014716157 0.015242215 0.015637501 #>  #> $unadj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $unadj$os #>  [1] 0.000000000 0.009363175 0.012472587 0.014891286 0.016981265 0.018871673 #>  [7] 0.020625521 0.022278934 0.023854812 0.025368713 0.026831756 #>  #> $unadj$pps #>  [1]        NaN 0.11640992 0.06026855 0.04720160 0.04346609 0.04281332 #>  [7] 0.04340284 0.04448366 0.04559770 0.04699859 0.04859870 #>  #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ibs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","title":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","text":"Calculate integrated Brier score overall survival decision model. function essentially wrapper SurvMetrics::IBS use package.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ibs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","text":"","code":"calc_ibs(ptdata, dpam)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ibs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions model endpoints. include six endpoints.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ibs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","text":"List containing osibs: Vector integrated Brier scores PSM, STM-CF STM-CR decision models timerange: Vector time range integrated Brier score calculated","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ibs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Integrated Brier Scores for Overall Survival — calc_ibs","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_par(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_par(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_par(fits$pfs, \"aic\")$fit,   os = find_bestfit_par(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_par(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_par(fits$pps_cr, \"aic\")$fit   ) # Not run (takes a long time) # calc_ibs(bosonc, params)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihoods for three three-state model structures — calc_likes","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"Calculate likelihood values summary output following three state models structures: partitioned survival, clock forward state transition, clock reset state transition. function requires appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"","code":"calc_likes(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"Two outputs returned: results tibble values data relating likelihood model: npts: Number patients analysed endpoint. likedata: Patient-level dataset additional likelihood-related calculations. coefsdists: Summary table distributions parameters used endpoint. slikes: Total log-likelihood possible outcome ll: Total log-likelihood params: Number parameters used model AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model llcomp tibble providing breakdown likelihood calculations outcome. Outcomes follows: (1) refers patients remain alive progression-free follow-; (2) refers patients die without prior progression follow-; (3) refers patients progress remain alive remaining follow-, (4) refers patients progress die within follow-. number patients outcome given model structure. may confirm identical across model structures. contribution patient group calculation log-likelihood model given fields beginning ll_. helpful understanding differences likelihoods model structures, according patient outcomes.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) calc_likes(bosonc, dpam=params) #> $detailed #> # A tibble: 6 × 7 #>   valid outcome  npts   ll_1   ll_2   ll_3   ll_4 #>   <lgl>   <dbl> <int>  <dbl>  <dbl>  <dbl>  <dbl> #> 1 FALSE       4     1   NA     NA     NA     NA   #> 2 TRUE        1    72  -64.8  -64.8  -65.2  -65.2 #> 3 TRUE        2    29 -152.  -147.  -147.  -147.  #> 4 TRUE        3    35 -151.  -150.  -148.  -148.  #> 5 TRUE        4    67 -469.    NA     NA     NA   #> 6 TRUE        4    68   NA   -473.  -473.  -470.  #>  #> $valid #> # A tibble: 4 × 6 #>   methno methname    npts_TRUE npts_FALSE ll_TRUE ll_FALSE #>    <dbl> <chr>           <int>      <int>   <dbl>    <dbl> #> 1      1 psm_simple        203          1   -836.    NA    #> 2      2 psm_complex       203          1   -830.    -5.25 #> 3      3 stm_cf            203          1   -828.    -5.45 #> 4      4 stm_cr            203          1   -824.    -6.08 #>  #> $sumall #> # A tibble: 8 × 10 #>   validall methno methname     npts      ll nparam   aic   bic rank_aic rank_bic #>   <lgl>     <dbl> <chr>       <int>   <dbl>  <dbl> <dbl> <dbl>    <dbl>    <dbl> #> 1 FALSE         1 psm_simple      1   NA         7   NA    NA        NA       NA #> 2 FALSE         2 psm_complex     1   -5.25      9   NA    NA        NA       NA #> 3 FALSE         3 stm_cf          1   -5.45      9   NA    NA        NA       NA #> 4 FALSE         4 stm_cr          1   -6.08     10   NA    NA        NA       NA #> 5 TRUE          1 psm_simple    203 -836.        7 1685. 1709.        4        4 #> 6 TRUE          2 psm_complex   203 -830.        9 1679. 1708.        3        3 #> 7 TRUE          3 stm_cf        203 -828.        9 1673. 1703.        2        2 #> 8 TRUE          4 stm_cr        203 -824.       10 1668. 1701.        1        1 #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_complex.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","title":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","text":"Calculate likelihood values summary output complex three-state partitioned survival model, given appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used). function called calc_likes(). Unlike calc_likes_psm_simple(), likelihood function requires fitting TTP.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_complex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","text":"","code":"calc_likes_psm_complex(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_complex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_complex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","text":"List values data relating likelihood model: npts: Number patients analysed endpoint. likedata: Patient-level dataset additional likelihood-related calculations. coefsdists: Summary table distributions parameters used endpoint. slikes: Total log-likelihood possible outcome ll: Total log-likelihood params: Number parameters used model AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_complex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihood for a more complex three-state partitioned survival model — calc_likes_psm_complex","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_par(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_par(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_par(fits$pfs, \"aic\")$fit,   os = find_bestfit_par(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_par(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_par(fits$pps_cr, \"aic\")$fit   ) calc_likes_psm_complex(bosonc, dpam=params) #> $npts #> [1] 204 204 #>  #> $npar #> [1] 5 #>  #> $ll #> [1] -Inf -Inf #>  #> $data #> # A tibble: 204 × 22 #>     ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag  hpfsu  spfsu #>    <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>  <dbl>  <dbl> #>  1     1   18.7          1   42.9        1   18.7          1 0.0560 0.352  #>  2     2   12.0          1   23.3        1   12.0          1 0.0560 0.511  #>  3     3    0.452        1    8.81       1    0.452        1 0.0560 0.975  #>  4     4    9.07         1   52.7        1    9.07         1 0.0560 0.602  #>  5     5   47.7          0   47.7        0   47.7          0 0.0560 0.0692 #>  6     6    3.26         1   13.1        1    3.26         1 0.0560 0.833  #>  7     7    0.738        1    2.74       1    0.738        1 0.0560 0.960  #>  8     8   35.5          1   35.5        1   35.5          0 0.0560 0.137  #>  9     9   10.4          1   37.1        1   10.4          1 0.0560 0.560  #> 10    10   10.5          1   32.7        1   10.5          1 0.0560 0.557  #> # ℹ 194 more rows #> # ℹ 13 more variables: hppdu <dbl>, httpu <dbl>, sppstu <dbl>, hppst <dbl>, #> #   f1 <dbl>, f2 <dbl>, f3 <dbl>, f4 <dbl>, like <dbl>, llike <dbl>, #> #   outcome <dbl>, chf <lgl>, valid <lgl> #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","title":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","text":"Calculate likelihood values summary output simple three-state partitioned survival model, given appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used). function called calc_likes.x three-state partitioned survival model, given appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used). function called calc_likes. Unlike calc_likes_psm_complex, likelihood function assumes progression hazard can derived PFS hazard function ratio progression PFS events PF patients.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","text":"","code":"calc_likes_psm_simple(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","text":"List values data relating likelihood model: npts: Number patients analysed endpoint. likedata: Patient-level dataset additional likelihood-related calculations. coefsdists: Summary table distributions parameters used endpoint. slikes: Total log-likelihood possible outcome ll: Total log-likelihood params: Number parameters used model AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_psm_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihood for a simple three-state partitioned survival model — calc_likes_psm_simple","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) calc_likes_psm_simple(bosonc, dpam=params) #> $npts #> [1] 204 203 #>  #> $npar #> [1] 7 #>  #> $ll #> [1]        NA -835.7038 #>  #> $data #> # A tibble: 204 × 22 #>     ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag  hpfsu spfsu #>    <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>  <dbl> <dbl> #>  1     1   18.7          1   42.9        1   18.7          1 0.0490 0.349 #>  2     2   12.0          1   23.3        1   12.0          1 0.0549 0.493 #>  3     3    0.452        1    8.81       1    0.452        1 0.0621 0.971 #>  4     4    9.07         1   52.7        1    9.07         1 0.0574 0.581 #>  5     5   47.7          0   47.7        0   47.7          0 0.0324 0.110 #>  6     6    3.26         1   13.1        1    3.26         1 0.0603 0.819 #>  7     7    0.738        1    2.74       1    0.738        1 0.0611 0.954 #>  8     8   35.5          1   35.5        1   35.5          0 0.0379 0.169 #>  9     9   10.4          1   37.1        1   10.4          1 0.0563 0.540 #> 10    10   10.5          1   32.7        1   10.5          1 0.0562 0.537 #> # ℹ 194 more rows #> # ℹ 13 more variables: hppdu <dbl>, httpu <dbl>, sppstu <dbl>, hppst <dbl>, #> #   f1 <dbl>, f2 <dbl>, f3 <dbl>, f4 <dbl>, like <dbl>, llike <dbl>, #> #   outcome <dbl>, chf <lgl>, valid <lgl> #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","title":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","text":"Calculate likelihood values summary output three-state clock forward state transition model, given appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used). function called calc_likes.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","text":"","code":"calc_likes_stm_cf(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","text":"List values data relating likelihood model: npts: Number patients analysed endpoint. likedata: Patient-level dataset additional likelihood-related calculations. coefsdists: Summary table distributions parameters used endpoint. slikes: Total log-likelihood possible outcome ll: Total log-likelihood params: Number parameters used model AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihood for a three-state clock forward state transition model — calc_likes_stm_cf","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) calc_likes_stm_cf(bosonc, dpam=params) #> $npts #> [1] 204 204 #>  #> $npar #> [1] 9 #>  #> $ll #> [1] -833.162 -833.162 #>  #> $data #> # A tibble: 204 × 23 #>     ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag  httpu sttpu #>    <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>  <dbl> <dbl> #>  1     1   18.7          1   42.9        1   18.7          1 0.0326 0.448 #>  2     2   12.0          1   23.3        1   12.0          1 0.0387 0.567 #>  3     3    0.452        1    8.81       1    0.452        1 0.0623 0.971 #>  4     4    9.07         1   52.7        1    9.07         1 0.0421 0.638 #>  5     5   47.7          0   47.7        0   47.7          0 0.0196 0.218 #>  6     6    3.26         1   13.1        1    3.26         1 0.0502 0.833 #>  7     7    0.738        1    2.74       1    0.738        1 0.0594 0.954 #>  8     8   35.5          1   35.5        1   35.5          0 0.0233 0.282 #>  9     9   10.4          1   37.1        1   10.4          1 0.0406 0.605 #> 10    10   10.5          1   32.7        1   10.5          1 0.0405 0.603 #> # ℹ 194 more rows #> # ℹ 14 more variables: hppdu <dbl>, sppdu <dbl>, sppsu <dbl>, sppst <dbl>, #> #   hppst <dbl>, f1 <dbl>, f2 <dbl>, f3 <dbl>, f4 <dbl>, like <dbl>, #> #   llike <dbl>, outcome <dbl>, chf <lgl>, valid <lgl> #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","title":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","text":"Calculate likelihood values summary output three-state clock reset model, given appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used). function called calc_likes.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","text":"","code":"calc_likes_stm_cr(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","text":"List values data relating likelihood model: npts: Number patients analysed endpoint. likedata: Patient-level dataset additional likelihood-related calculations. coefsdists: Summary table distributions parameters used endpoint. slikes: Total log-likelihood possible outcome ll: Total log-likelihood params: Number parameters used model AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihood for a three-state clock reset state transition model — calc_likes_stm_cr","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) calc_likes_stm_cr(bosonc, dpam=params) #> $npts #> [1] 204 204 #>  #> $npar #> [1] 10 #>  #> $ll #> [1] -829.8603 -829.8603 #>  #> $data #> # A tibble: 204 × 23 #>     ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag  httpu sttpu #>    <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>  <dbl> <dbl> #>  1     1   18.7          1   42.9        1   18.7          1 0.0326 0.448 #>  2     2   12.0          1   23.3        1   12.0          1 0.0387 0.567 #>  3     3    0.452        1    8.81       1    0.452        1 0.0623 0.971 #>  4     4    9.07         1   52.7        1    9.07         1 0.0421 0.638 #>  5     5   47.7          0   47.7        0   47.7          0 0.0196 0.218 #>  6     6    3.26         1   13.1        1    3.26         1 0.0502 0.833 #>  7     7    0.738        1    2.74       1    0.738        1 0.0594 0.954 #>  8     8   35.5          1   35.5        1   35.5          0 0.0233 0.282 #>  9     9   10.4          1   37.1        1   10.4          1 0.0406 0.605 #> 10    10   10.5          1   32.7        1   10.5          1 0.0405 0.603 #> # ℹ 194 more rows #> # ℹ 14 more variables: hppdu <dbl>, sppdu <dbl>, hppdt <dbl>, sppstu <dbl>, #> #   hppstu <dbl>, f1 <dbl>, f2 <dbl>, f3 <dbl>, f4 <dbl>, like <dbl>, #> #   llike <dbl>, outcome <dbl>, chf <lgl>, valid <lgl> #>"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltdens.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate mortality density from a lifetable — calc_ltdens","title":"Calculate mortality density from a lifetable — calc_ltdens","text":"Calculate mortality density given time, according provided lifetable","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltdens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate mortality density from a lifetable — calc_ltdens","text":"","code":"calc_ltdens(looktime, lifetable = NA, method = \"geom\")"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltdens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate mortality density from a lifetable — calc_ltdens","text":"looktime time(s) survival estimated (time zero). lifetable lifetable must dataframe columns named lttime (years) lx. first entry time column must zero. Data sorted ascending order time, times must unique. method Method may floor, ceiling, arith geom (default).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltdens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate mortality density from a lifetable — calc_ltdens","text":"Numeric survival probability","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltdens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate mortality density from a lifetable — calc_ltdens","text":"","code":"ltable <- tibble::tibble(lttime=0:10, lx=10-(0:10)) calc_ltdens(c(2, 2.5, 9.3), ltable) #> [1] 0.1068251        NA        NA"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltsurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate survival from a lifetable — calc_ltsurv","title":"Calculate survival from a lifetable — calc_ltsurv","text":"Calculate survival time zero given time, according provided lifetable","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltsurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate survival from a lifetable — calc_ltsurv","text":"","code":"calc_ltsurv(looktime, lifetable = NA, method = \"geom\")"},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltsurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate survival from a lifetable — calc_ltsurv","text":"looktime time(s) survival estimated (time zero). lifetable lifetable must dataframe columns named lttime (years) lx. first entry time column must zero. Data sorted ascending order time, times must unique. method Method may floor, ceiling, arith geom (default).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltsurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate survival from a lifetable — calc_ltsurv","text":"Numeric survival probability","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_ltsurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate survival from a lifetable — calc_ltsurv","text":"","code":"ltable <- tibble::tibble(lttime=0:10, lx=10-(0:10)) calc_ltsurv(c(2, 2.5, 9.3), ltable) #> [1] 0.8000000 0.7483315 0.0000000"},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the distribution function — calc_pdist","title":"Calculate the distribution function — calc_pdist","text":"Calculate value distribution function, given regular parametric Royston-Parmar formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the distribution function — calc_pdist","text":"","code":"calc_pdist(time, type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the distribution function — calc_pdist","text":"time time distribution function calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the distribution function — calc_pdist","text":"value distribution function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the distribution function — calc_pdist","text":"","code":"calc_pdist(time=1:5,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 3.705619e-03 5.624390e-05 1.174259e-06 3.136877e-08 1.021446e-09 calc_pdist(time=1:5,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 0.001349898 0.010531513 0.028625624 0.053295645 0.082179130"},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the distribution function for parametric functions — calc_pdist_par","title":"Calculate the distribution function for parametric functions — calc_pdist_par","text":"Calculate value distribution function parametric distribution, given statistical distribution parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the distribution function for parametric functions — calc_pdist_par","text":"","code":"calc_pdist_par(time, dist, pars)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the distribution function for parametric functions — calc_pdist_par","text":"time time distribution function calculated. dist statistical distribution (named per flexsurv::flexsurvreg). pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the distribution function for parametric functions — calc_pdist_par","text":"value distribution function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_pdist_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the distribution function for parametric functions — calc_pdist_par","text":"","code":"calc_pdist_par(10, \"exp\", 0.01) #> [1] 0.09516258 calc_pdist_par(5, \"lnorm\", c(3, 1)) #> [1] 0.08217913"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean durations — calc_rmd","title":"Calculate restricted mean durations — calc_rmd","text":"Calculates restricted mean duration, given form parametric distribution Royston-Parmar splines","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean durations — calc_rmd","text":"","code":"calc_rmd(Tw, type, spec, discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean durations — calc_rmd","text":"Tw time horizon (weeks) mean calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times. discrate Discounting rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean durations — calc_rmd","text":"value hazard function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted mean durations — calc_rmd","text":"","code":"calc_rmd(Tw=200,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 199.9296 calc_rmd(Tw=250,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 32.45453"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_first.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean duration in respect of the first part of a two-piece model Internal function to calculate the restricted mean duration up to the cut-off time, the first part of a two-piece model. Assumes the time horizon is beyond the cutoff time. — calc_rmd_first","title":"Calculate restricted mean duration in respect of the first part of a two-piece model Internal function to calculate the restricted mean duration up to the cut-off time, the first part of a two-piece model. Assumes the time horizon is beyond the cutoff time. — calc_rmd_first","text":"Calculate restricted mean duration respect first part two-piece model Internal function calculate restricted mean duration cut-time, first part two-piece model. Assumes time horizon beyond cutoff time.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_first.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean duration in respect of the first part of a two-piece model Internal function to calculate the restricted mean duration up to the cut-off time, the first part of a two-piece model. Assumes the time horizon is beyond the cutoff time. — calc_rmd_first","text":"","code":"calc_rmd_first(ds, cuttime)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_first.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean duration in respect of the first part of a two-piece model Internal function to calculate the restricted mean duration up to the cut-off time, the first part of a two-piece model. Assumes the time horizon is beyond the cutoff time. — calc_rmd_first","text":"ds patient-level dataset cuttime time cut-","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_first.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean duration in respect of the first part of a two-piece model Internal function to calculate the restricted mean duration up to the cut-off time, the first part of a two-piece model. Assumes the time horizon is beyond the cutoff time. — calc_rmd_first","text":"list containing: pfsurv: PF survival function cut-time pfarea: area PF survival function cut-time ossurv: OS survival function cut-time osarea: area OS survival function cut-time","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean durations (parametric form) — calc_rmd_par","title":"Calculate restricted mean durations (parametric form) — calc_rmd_par","text":"Calculates restricted mean duration, given parametric statistical distribution.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean durations (parametric form) — calc_rmd_par","text":"","code":"calc_rmd_par(Tw, dist, pars)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean durations (parametric form) — calc_rmd_par","text":"Tw time period restricted mean calculated dist statistical distribution (named per flexsurv::flexsurvreg). pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean durations (parametric form) — calc_rmd_par","text":"restricted mean duration, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted mean durations (parametric form) — calc_rmd_par","text":"","code":"calc_rmd_par(20, \"exp\", 0.2) #> [1] 4.908422 calc_rmd_par(10, \"lnorm\", c(3, 1)) #> [1] 9.056158"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the value of the survival function — calc_surv","title":"Calculate the value of the survival function — calc_surv","text":"Calculate value survival function, given statistical distribution parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the value of the survival function — calc_surv","text":"","code":"calc_surv(time, type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the value of the survival function — calc_surv","text":"time time distribution function calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the value of the survival function — calc_surv","text":"value survival function, numeric value.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the value of the survival function — calc_surv","text":"","code":"calc_surv(time=1:5,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 0.9962944 0.9999438 0.9999988 1.0000000 1.0000000 calc_surv(time=1:5,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 0.9986501 0.9894685 0.9713744 0.9467044 0.9178209"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive PPS survival function under a PSM — calc_surv_psmpps","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"Derive post-progression survival (PPS) function simple complex PSM formulation.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"","code":"calc_surv_psmpps(totime, fromtime = 0, ptdata, dpam, psmtype = \"simple\")"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"totime Vector times survival function calculated fromtime Vector times survival function calculated ptdata Patient-level dataset dpam List fitted survival models endpoint psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"Vector PPS survival function values","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit   ) # calc_surv_psmpps(totime=1:10, #   fromtime=rep(1,10), #   ptdata=bosonc, #   dpam=params, #   type=\"simple\")"},{"path":"https://merck.github.io/psm3mkv/reference/check_posdef.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","title":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","text":"Checks whether Hessian matrix returned list fitting survival regression flexsurvreg positive-definite.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_posdef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","text":"","code":"check_posdef(fitlist)"},{"path":"https://merck.github.io/psm3mkv/reference/check_posdef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","text":"fitlist list returned running flexsurv::flexsurvreg() describing fitted survival model","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_posdef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","text":"logical: TRUE Hessian matrix positive definite, FALSE .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_posdef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks whether the Hessian for a survival regression is positive-definite — check_posdef","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) check_posdef(fits$pfs[[2]]$result) #> [1] TRUE"},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"Constrain survival probabilities according hazards lifetable Recalculated constrained survival probabilities (week) lower original unadjusted survival probability survival implied given lifetable (assumed indexed years).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"","code":"constrain_survprob(   survprob1,   survprob2 = NA,   lifetable = NA,   timevec = 0:(length(survprob1) - 1) )"},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"survprob1 (Unconstrained) survival probability value vector survprob2 Optional survival probability value vector constrain (default = NA) lifetable Lifetable (default = NA) timevec Vector times corresponding survival probabilities ","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"Vector constrained survival probabilities","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"","code":"ltable <- tibble::tibble(lttime=0:20, lx=c(1,0.08,0.05,0.03,0.01,rep(0,16))) survprob <- c(1,0.5,0.4,0.2,0) constrain_survprob(survprob, lifetable=ltable) #> [1] 1.0 0.5 0.4 0.2 0.0 timevec <- 100*(0:4) constrain_survprob(survprob, lifetable=ltable, timevec=timevec) #> [1] 1.00000000 0.05200139 0.01201389 0.00000000 0.00000000 survprob2 <- c(1,0.45,0.35,0.15,0) constrain_survprob(survprob, survprob2) #> [1] 1.00 0.45 0.35 0.15 0.00"},{"path":"https://merck.github.io/psm3mkv/reference/convert_fit2spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","title":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","text":"Obtain type specification required package functions model fit","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_fit2spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","text":"","code":"convert_fit2spec(fitsurv)"},{"path":"https://merck.github.io/psm3mkv/reference/convert_fit2spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","text":"fitsurv Fitted model (either parametric Royston-Parmar splines model)","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_fit2spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","text":"List type specification type \"spl\" splines model \"par\" parametric model spec contains distribution (dist) coefficients (coefs) type==\"par\" spec contains gamma values (gamma), knot locations (log scale, knots) scale (scale) Royston-Parmar splines model, type==\"spl\"","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/convert_fit2spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain the type and specification as required in other package functions from a model fit — convert_fit2spec","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) convert_fit2spec(fits$pfs[[3]]$result) #> $type #> [1] \"spl\" #>  #> $spec #> $spec$gamma #>      gamma0      gamma1      gamma2  #> -1.62401396  0.37081783 -0.02243188  #>  #> $spec$knots #>                 50%            #> -2.233592  2.008522  3.882300  #>  #> $spec$k #> [1] 1 #>  #> $spec$scale #> [1] \"normal\" #>  #>"},{"path":"https://merck.github.io/psm3mkv/reference/convert_wks2yrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert weeks to years — convert_wks2yrs","title":"Convert weeks to years — convert_wks2yrs","text":"Convert weeks years. Function allows hard-coding minimized elsewhere package.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_wks2yrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert weeks to years — convert_wks2yrs","text":"","code":"convert_wks2yrs(weeks)"},{"path":"https://merck.github.io/psm3mkv/reference/convert_wks2yrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert weeks to years — convert_wks2yrs","text":"weeks Number weeks","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_wks2yrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert weeks to years — convert_wks2yrs","text":"Number years = weeks x 7 / 365.25","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/convert_yrs2wks.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert years to weeks — convert_yrs2wks","title":"Convert years to weeks — convert_yrs2wks","text":"Convert weeks years. Function allows hard-coding minimized elsewhere package.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_yrs2wks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert years to weeks — convert_yrs2wks","text":"","code":"convert_yrs2wks(years)"},{"path":"https://merck.github.io/psm3mkv/reference/convert_yrs2wks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert years to weeks — convert_yrs2wks","text":"years Number years","code":""},{"path":"https://merck.github.io/psm3mkv/reference/convert_yrs2wks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert years to weeks — convert_yrs2wks","text":"Number weeks = years / 7 * 365.25","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dummy dataset for illustration — create_dummydata","title":"Create dummy dataset for illustration — create_dummydata","text":"Create dummy dataset illustrate psm3mkv","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dummy dataset for illustration — create_dummydata","text":"","code":"create_dummydata(dsname)"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create dummy dataset for illustration — create_dummydata","text":"dsname Dataset name, follows: 'flexbosms' provides dataset based flexsurv::bosms3(). contains fields necessary psm3mkv. 'survcan' provides dataset based survival::cancer(). contains necessary ID overall survival fields. additionally need supply PFS TTP data (fields pfs.durn, pfs.flag, ttp.durn ttp.flag) use psm3mkv.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create dummy dataset for illustration — create_dummydata","text":"Tibble dataset, use psm3mkv functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create dummy dataset for illustration — create_dummydata","text":"","code":"create_dummydata(\"survcan\") |> head() #>   ptid   os.durn os.flag #> 1    1  43.71429       1 #> 2    2  65.00000       1 #> 3    3 144.28571       0 #> 4    4  30.00000       1 #> 5    5 126.14286       1 #> 6    6 146.00000       0 create_dummydata(\"flexbosms\") |> head() #> # A tibble: 6 × 7 #>    ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag #>   <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl> #> 1     1   18.7          1   42.9        1   18.7          1 #> 2     2   12.0          1   23.3        1   12.0          1 #> 3     3    0.452        1    8.81       1    0.452        1 #> 4     4    9.07         1   52.7        1    9.07         1 #> 5     5   47.7          0   47.7        0   47.7          0 #> 6     6    3.26         1   13.1        1    3.26         1"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_flexbosms.html","id":null,"dir":"Reference","previous_headings":"","what":"Create flexbosms dataset for illustration — create_dummydata_flexbosms","title":"Create flexbosms dataset for illustration — create_dummydata_flexbosms","text":"Create 'flexbosms' dummy dataset illustrate psm3mkv","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_flexbosms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create flexbosms dataset for illustration — create_dummydata_flexbosms","text":"","code":"create_dummydata_flexbosms()"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_flexbosms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create flexbosms dataset for illustration — create_dummydata_flexbosms","text":"Tibble dataset, use psm3mkv functions","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_survcan.html","id":null,"dir":"Reference","previous_headings":"","what":"Create survcan dummy dataset for illustration — create_dummydata_survcan","title":"Create survcan dummy dataset for illustration — create_dummydata_survcan","text":"Create 'survcan' dummy dataset illustrate psm3mkv","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_survcan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create survcan dummy dataset for illustration — create_dummydata_survcan","text":"","code":"create_dummydata_survcan()"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata_survcan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create survcan dummy dataset for illustration — create_dummydata_survcan","text":"Tibble dataset, use psm3mkv functions","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"Create additional time--event endpoints, adjusting cutpoint","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"","code":"create_extrafields(ds, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"ds Patient-level dataset cuttime Time cutpoint","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"Dataset complete patient-level dataset, adjusted cutpoint","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") create_extrafields(bosonc, cuttime=10) #> # A tibble: 204 × 16 #>     ptid pfs.odurn pfs.flag os.odurn os.flag ttp.odurn ttp.flag ttp.durn #>    <int>     <dbl>    <dbl>    <dbl>   <dbl>     <dbl>    <dbl>    <dbl> #>  1     1    18.7          1    42.9        1    18.7          1    8.67  #>  2     2    12.0          1    23.3        1    12.0          1    2.01  #>  3     3     0.452        1     8.81       1     0.452        1    0     #>  4     4     9.07         1    52.7        1     9.07         1    0     #>  5     5    47.7          0    47.7        0    47.7          0   37.7   #>  6     6     3.26         1    13.1        1     3.26         1    0     #>  7     7     0.738        1     2.74       1     0.738        1    0     #>  8     8    35.5          1    35.5        1    35.5          0   25.5   #>  9     9    10.4          1    37.1        1    10.4          1    0.369 #> 10    10    10.5          1    32.7        1    10.5          1    0.464 #> # ℹ 194 more rows #> # ℹ 8 more variables: pfs.durn <dbl>, os.durn <dbl>, tzero <dbl>, #> #   pps.odurn <dbl>, pps.durn <dbl>, pps.flag <dbl>, ppd.durn <dbl>, #> #   ppd.flag <dbl>"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","title":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","text":"Discretized Restricted Mean Duration calculation Partitioned Survival Model Calculate restricted mean duration (RMD) PF, PD OS states Partitioned Survival Model structure.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","text":"","code":"drmd_psm(   ptdata,   dpam,   psmtype = \"simple\",   Ty = 10,   discrate = 0,   lifetable = NA,   timestep = 1 )"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). psmtype Either \"simple\" \"complex\" PSM formulation Ty Time duration calculate (defaults 10 years). Assumes input years, patient-level data recorded weeks. discrate Discount rate (%) per year (defaults zero). lifetable Optional. lifetable must dataframe columns named time lx. first entry time column must zero. Data sorted ascending order time, times must unique. timestep Optional, defaults one (week).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","text":"List containing: pf: RMD PF state pd: RMD PD state os: RMD either alive state","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/drmd_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretized Restricted Mean Duration calculation for Partitioned Survival Model Calculate restricted mean duration (RMD) in PF, PD and OS states under a Partitioned Survival Model structure. — drmd_psm","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) drmd_psm(ptdata=bosonc, dpam=params) #> $pf #> [1] 18.41549 #>  #> $pd #> [1] 8.823256 #>  #> $os #> [1] 27.23875 #>  # Add a lifetable constraint ltable <- tibble::tibble(lttime=0:20, lx=1-lttime*0.05) drmd_psm(ptdata=bosonc, dpam=params, lifetable=ltable) #> $pf #> [1] 18.41549 #>  #> $pd #> [1] 8.823256 #>  #> $os #> [1] 27.23875 #>"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","text":"Discretized Restricted Mean Duration calculation State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) PF, PD OS states State Transition Model Clock Forward structure.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","text":"","code":"drmd_stm_cf(dpam, Ty = 10, discrate = 0, lifetable = NA, timestep = 1)"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate (defaults 10 years). Assumes input years, patient-level data recorded weeks. discrate Discount rate (%) per year (defaults zero). lifetable Optional. lifetable must dataframe columns named time lx. first entry time column must zero. Data sorted ascending order time, times must unique. timestep Optional, defaults one (week).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","text":"List containing: pf: RMD PF state pd: RMD PD state os: RMD either alive state","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Forward structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Forward structure. — drmd_stm_cf","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) drmd_stm_cf(dpam=params) #> $pf #> [1] 18.96864 #>  #> $pd #> [1] 10.87732 #>  #> $os #> [1] 29.84596 #>  # Add a lifetable constraint ltable <- tibble::tibble(lttime=0:20, lx=1-lttime*0.05) drmd_stm_cf(dpam=params, lifetable=ltable) #> $pf #> [1] 18.96864 #>  #> $pd #> [1] 10.87732 #>  #> $os #> [1] 29.84596 #>"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","text":"Discretized Restricted Mean Duration calculation State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) PF, PD OS states State Transition Model Clock Reset structure.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","text":"","code":"drmd_stm_cr(dpam, Ty = 10, discrate = 0, lifetable = NA, timestep = 1)"},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate (defaults 10 years). Assumes input years, patient-level data recorded weeks. discrate Discount rate (%) per year (defaults zero). lifetable Optional. lifetable must dataframe columns named time lx. first entry time column must zero. Data sorted ascending order time, times must unique. timestep Optional, defaults one (week).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","text":"List containing: pf: RMD PF state pd: RMD PD state os: RMD either alive state","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/drmd_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretized Restricted Mean Duration calculation for State Transition Model Clock Reset structure Calculate restricted mean duration (RMD) in PF, PD and OS states under a State Transition Model Clock Reset structure. — drmd_stm_cr","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) drmd_stm_cr(dpam=params) #> $pf #> [1] 18.96864 #>  #> $pd #> [1] 11.05433 #>  #> $os #> [1] 30.02297 #>  # Add a lifetable constraint (not run because it's slow) # ltable <- tibble::tibble(lttime=0:20, lx=1-lttime*0.05) # drmd_stm_cr(dpam=params, lifetable=ltable)"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the ","title":"Find the ","text":"multiple survival regressions fitted endpoint dataset, necessary identify preferred model. function reviews fitted regressions selects minimum Akaike Bayesian Information Criterion (AIC, BIC), depending user choice.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the ","text":"","code":"find_bestfit_par(reglist, crit)"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the ","text":"reglist List fitted survival regressions endpoint dataset. crit Criterion used selection best fit, either \"aic\" (Akaike Information Criterion) \"bic\" (Bayesian Information Criterion).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the ","text":"List single survival regression best fit.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the ","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") # Pick some distributions to fit to all endpoints dists <- c(\"exp\", \"llogis\", \"lnorm\") # Fit all distributions to all endpoints fits <- fit_ends_mods_par(bosonc,     cuttime = 0,     ppd.dist = dists,     ttp.dist = dists,     pfs.dist = dists,     os.dist = dists,     pps_cr.dist = dists,     pps_cf.dist = dists) find_bestfit_par(fits$ttp, \"aic\") #> $fit #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape   1.0300   0.8726   1.2158   0.0872 #> scale  15.4175  11.8479  20.0625   2.0716 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.068, df = 2 #> AIC = 848.136 #>  #>  #> $results #> # A tibble: 3 × 11 #>      id dists   npts  pars loglik conv  posdef   aic   bic rankaic rankbic #>   <int> <chr>  <dbl> <dbl>  <dbl> <lgl> <lgl>  <dbl> <dbl>   <dbl>   <dbl> #> 1     1 exp      204     1  -426. TRUE  TRUE    853.  856.       3       2 #> 2     2 llogis   204     2  -422. TRUE  TRUE    848.  855.       1       1 #> 3     3 lnorm    204     2  -424. TRUE  TRUE    851.  858.       2       3 #>  find_bestfit_par(fits$os, \"bic\") #> $fit #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape   1.814   1.541   2.136   0.151 #> scale  23.832  20.361  27.895   1.914 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -436.9493, df = 2 #> AIC = 877.8987 #>  #>  #> $results #> # A tibble: 3 × 11 #>      id dists   npts  pars loglik conv  posdef   aic   bic rankaic rankbic #>   <int> <chr>  <dbl> <dbl>  <dbl> <lgl> <lgl>  <dbl> <dbl>   <dbl>   <dbl> #> 1     1 exp      204     1  -444. TRUE  TRUE    890.  894.       3       3 #> 2     2 llogis   204     2  -437. TRUE  TRUE    878.  885.       1       1 #> 3     3 lnorm    204     2  -439. TRUE  TRUE    883.  889.       2       2 #>"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_spl.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the ","title":"Find the ","text":"multiple spline models fitted endpoint dataset, necessary identify preferred model. function reviews fitted regressions selects minimum Akaike Bayesian Information Criterion (AIC, BIC), depending user choice.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_spl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the ","text":"","code":"find_bestfit_spl(reglist, crit = \"aic\")"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_spl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the ","text":"reglist List fitted spline models endpoint dataset. crit Criterion used selection best fit, either \"aic\" (Akaike Information Criterion) \"bic\" (Bayesian Information Criterion).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_spl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the ","text":"List single survival regression best fit.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit_spl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the ","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) find_bestfit_spl(fits$ttp, \"aic\") #> $fit #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.60314  -1.83224  -1.37404   0.11689 #> gamma1   0.38216   0.20690   0.55743   0.08942 #> gamma2  -0.01936  -0.03709  -0.00163   0.00905 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.5655, df = 3 #> AIC = 849.1309 #>  #>  #> $results #> # A tibble: 9 × 11 #>      id nknots scales  npts  pars loglik conv    aic   bic rankaic rankbic #>   <int>  <dbl> <chr>  <dbl> <dbl>  <dbl> <lgl> <dbl> <dbl>   <dbl>   <dbl> #> 1     1      1 hazard   204     3  -423. TRUE   852.  862.       8       3 #> 2     2      1 odds     204     3  -422. TRUE   849.  859.       2       2 #> 3     3      1 normal   204     3  -422. TRUE   849.  859.       1       1 #> 4     4      2 hazard   204     4  -423. TRUE   854.  867.       9       8 #> 5     5      2 odds     204     4  -421. TRUE   851.  864.       7       5 #> 6     6      2 normal   204     4  -421. TRUE   851.  864.       6       4 #> 7     7      3 hazard   204     5  -420. TRUE   850.  867.       5       9 #> 8     8      3 odds     204     5  -420. TRUE   850.  867.       3       6 #> 9     9      3 normal   204     5  -420. TRUE   850.  867.       4       7 #>"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_given.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit survival models to each endpoint, given type and spec Internal function to fit survival models to each endpoint, given type and spec in format of convert_fit2spec() — fit_ends_mods_given","title":"Fit survival models to each endpoint, given type and spec Internal function to fit survival models to each endpoint, given type and spec in format of convert_fit2spec() — fit_ends_mods_given","text":"Fit survival models endpoint, given type spec Internal function fit survival models endpoint, given type spec format convert_fit2spec()","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_given.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit survival models to each endpoint, given type and spec Internal function to fit survival models to each endpoint, given type and spec in format of convert_fit2spec() — fit_ends_mods_given","text":"","code":"fit_ends_mods_given(simdat, dpam, cuttime)"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_given.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit survival models to each endpoint, given type and spec Internal function to fit survival models to each endpoint, given type and spec in format of convert_fit2spec() — fit_ends_mods_given","text":"simdat (sample ) patient-level dataset dpam currently fitted set survival models endpoint cuttime cut-time two-piece modeling","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_given.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit survival models to each endpoint, given type and spec Internal function to fit survival models to each endpoint, given type and spec in format of convert_fit2spec() — fit_ends_mods_given","text":"list endpoint, distribution, containing two components: result: list class flexsurvreg containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"Fits multiple parametric survival regressions, according distributions stipulated, multiple endpoints required fitting partitioned survival analysis, clock forward clock reset semi-markov models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"","code":"fit_ends_mods_par(   simdat,   cuttime = 0,   ppd.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   ttp.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pfs.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   os.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pps_cf.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pps_cr.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   expvar = NA )"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"simdat Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. cuttime Cut-time two-piece model, equals zero one-piece models. ppd.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Pre-Progression Death (PPD). ttp.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Time Progression (TTP). pfs.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Progression-Free Survival (PFS). os.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Overall Survival (OS). pps_cf.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Post Progression Survival, time baseline (clock forward). pps_cr.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Post Progression Survival, time progression (clock reset). expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"list endpoint, distribution, containing two components: result: list class flexsurvreg containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fit_ends_mods_par(bosonc, expvar=bosonc$ttp.durn) #> $ttp #> $ttp[[1]] #> $ttp[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est     L95%    U95%    se     #> rate  0.0437  0.0360  0.0530  0.0043 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -425.5134, df = 1 #> AIC = 853.0269 #>  #>  #> $ttp[[1]]$error #> NULL #>  #>  #> $ttp[[2]] #> $ttp[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.8379  0.7110  0.9875  0.0702 #> scale  0.0680  0.0448  0.1033  0.0145 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.0927, df = 2 #> AIC = 850.1853 #>  #>  #> $ttp[[2]]$error #> NULL #>  #>  #> $ttp[[3]] #> $ttp[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape   1.0300   0.8726   1.2158   0.0872 #> scale  15.4175  11.8479  20.0625   2.0716 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.068, df = 2 #> AIC = 848.136 #>  #>  #> $ttp[[3]]$error #> NULL #>  #>  #> $ttp[[4]] #> $ttp[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  2.762  2.462  3.062  0.153 #> sdlog    1.777  1.535  2.057  0.133 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.7432, df = 2 #> AIC = 851.4864 #>  #>  #> $ttp[[4]]$error #> NULL #>  #>  #> $ttp[[5]] #> $ttp[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.80871  0.65294  1.00164  0.08828 #> rate   0.03166  0.02120  0.04730  0.00649 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.5205, df = 2 #> AIC = 851.0411 #>  #>  #> $ttp[[5]]$error #> NULL #>  #>  #> $ttp[[6]] #> $ttp[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  -0.0376  -0.0652  -0.0101   0.0141 #> rate    0.0603   0.0455   0.0800   0.0087 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3123, df = 2 #> AIC = 846.6246 #>  #>  #> $ttp[[6]]$error #> NULL #>  #>  #>  #> $ppd #> $ppd[[1]] #> $ppd[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.01229  0.00854  0.01769  0.00228 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -156.5603, df = 1 #> AIC = 315.1206 #>  #>  #> $ppd[[1]]$error #> NULL #>  #>  #> $ppd[[2]] #> $ppd[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  1.43499  1.09372  1.88274  0.19883 #> scale  0.00352  0.00105  0.01183  0.00218 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7336, df = 2 #> AIC = 311.4673 #>  #>  #> $ppd[[2]]$error #> NULL #>  #>  #> $ppd[[3]] #> $ppd[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape   1.553   1.174   2.055   0.222 #> scale  43.036  29.365  63.072   8.393 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0749, df = 2 #> AIC = 312.1498 #>  #>  #> $ppd[[3]]$error #> NULL #>  #>  #> $ppd[[4]] #> $ppd[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  3.923  3.450  4.397  0.242 #> sdlog    1.289  0.993  1.674  0.172 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.541, df = 2 #> AIC = 313.0821 #>  #>  #> $ppd[[4]]$error #> NULL #>  #>  #> $ppd[[5]] #> $ppd[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  1.5585  1.0961  2.2159  0.2799 #> rate   0.0303  0.0152  0.0605  0.0107 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7877, df = 2 #> AIC = 311.5754 #>  #>  #> $ppd[[5]]$error #> NULL #>  #>  #> $ppd[[6]] #> $ppd[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.03933  0.00681  0.07184  0.01659 #> rate   0.00777  0.00436  0.01385  0.00229 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.1277, df = 2 #> AIC = 312.2554 #>  #>  #> $ppd[[6]]$error #> NULL #>  #>  #>  #> $pfs #> $pfs[[1]] #> $pfs[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.05596  0.04718  0.06637  0.00487 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.5726, df = 1 #> AIC = 1027.145 #>  #>  #> $pfs[[1]]$error #> NULL #>  #>  #> $pfs[[2]] #> $pfs[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.9313  0.8080  1.0733  0.0675 #> scale  0.0676  0.0453  0.1009  0.0138 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0729, df = 2 #> AIC = 1028.146 #>  #>  #> $pfs[[2]]$error #> NULL #>  #>  #> $pfs[[3]] #> $pfs[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape   1.1921   1.0310   1.3784   0.0883 #> scale  11.4917   9.3244  14.1628   1.2254 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -513.4304, df = 2 #> AIC = 1030.861 #>  #>  #> $pfs[[3]]$error #> NULL #>  #>  #> $pfs[[4]] #> $pfs[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  2.412  2.179  2.645  0.119 #> sdlog    1.535  1.353  1.742  0.099 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -516.8304, df = 2 #> AIC = 1037.661 #>  #>  #> $pfs[[4]]$error #> NULL #>  #>  #> $pfs[[5]] #> $pfs[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.91518  0.75087  1.11544  0.09240 #> rate   0.04985  0.03633  0.06840  0.00805 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.1786, df = 2 #> AIC = 1028.357 #>  #>  #> $pfs[[5]]$error #> NULL #>  #>  #> $pfs[[6]] #> $pfs[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est       L95%      U95%      se       #> shape  -0.01338  -0.03435   0.00758   0.01070 #> rate    0.06342   0.04927   0.08165   0.00817 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7442, df = 2 #> AIC = 1027.488 #>  #>  #> $pfs[[6]]$error #> NULL #>  #>  #>  #> $os #> $os[[1]] #> $os[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.02788  0.02285  0.03402  0.00283 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -444.2435, df = 1 #> AIC = 890.4871 #>  #>  #> $os[[1]]$error #> NULL #>  #>  #> $os[[2]] #> $os[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  1.51429  1.29286  1.77364  0.12214 #> scale  0.00560  0.00254  0.01233  0.00226 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.3483, df = 2 #> AIC = 870.6965 #>  #>  #> $os[[2]]$error #> NULL #>  #>  #> $os[[3]] #> $os[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape   1.814   1.541   2.136   0.151 #> scale  23.832  20.361  27.895   1.914 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -436.9493, df = 2 #> AIC = 877.8987 #>  #>  #> $os[[3]]$error #> NULL #>  #>  #> $os[[4]] #> $os[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est     L95%    U95%    se     #> meanlog  3.1627  2.9845  3.3409  0.0909 #> sdlog    1.0166  0.8806  1.1734  0.0744 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -439.3941, df = 2 #> AIC = 882.7881 #>  #>  #> $os[[4]]$error #> NULL #>  #>  #> $os[[5]] #> $os[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  1.7620  1.3981  2.2207  0.2080 #> rate   0.0605  0.0435  0.0842  0.0102 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -434.1308, df = 2 #> AIC = 872.2617 #>  #>  #> $os[[5]]$error #> NULL #>  #>  #> $os[[6]] #> $os[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.04179  0.02473  0.05885  0.00870 #> rate   0.01532  0.01079  0.02173  0.00274 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.9344, df = 2 #> AIC = 871.8687 #>  #>  #> $os[[6]]$error #> NULL #>  #>  #>  #> $pps_cf #> $pps_cf[[1]] #> $pps_cf[[1]]$result #> NULL #>  #> $pps_cf[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[2]] #> $pps_cf[[2]]$result #> NULL #>  #> $pps_cf[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[3]] #> $pps_cf[[3]]$result #> NULL #>  #> $pps_cf[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[4]] #> $pps_cf[[4]]$result #> NULL #>  #> $pps_cf[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[5]] #> $pps_cf[[5]]$result #> NULL #>  #> $pps_cf[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[6]] #> $pps_cf[[6]]$result #> NULL #>  #> $pps_cf[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>  #> $pps_cr #> $pps_cr[[1]] #> $pps_cr[[1]]$result #> NULL #>  #> $pps_cr[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[2]] #> $pps_cr[[2]]$result #> NULL #>  #> $pps_cr[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[3]] #> $pps_cr[[3]]$result #> NULL #>  #> $pps_cr[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[4]] #> $pps_cr[[4]]$result #> NULL #>  #> $pps_cr[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[5]] #> $pps_cr[[5]]$result #> NULL #>  #> $pps_cr[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[6]] #> $pps_cr[[6]]$result #> NULL #>  #> $pps_cr[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"Fits multiple survival regressions, according distributions stipulated, multiple endpoints required fitting partitioned survival analysis, clock forward clock reset semi-markov models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"","code":"fit_ends_mods_spl(   simdat,   knot_set = 1:3,   scale_set = c(\"hazard\", \"odds\", \"normal\"),   expvar = NA )"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"simdat Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. knot_set vector numbers knots consider, following flexsurv::flexsurvspline()). scale_set vector spline scales consider, following flexsurv::flexsurvspline()). expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"list endpoint, distribution, containing two components: result: list class flexsurv::flexsurvspline containing information fitted model. error: error message returned fitting regression (NULL indicates error). Also, given cuttime.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"","code":"# Create dataset in suitable form using bos dataset from the flexsurv package bosonc <- create_dummydata(\"flexbosms\") fit_ends_mods_spl(bosonc, expvar=bosonc$ttp.durn) #> $ttp #> $ttp[[1]] #> $ttp[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7114  -3.1392  -2.2836   0.2183 #> gamma1   0.9650   0.5632   1.3668   0.2050 #> gamma2   0.0110  -0.0211   0.0432   0.0164 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.8569, df = 3 #> AIC = 851.7137 #>  #>  #> $ttp[[1]]$error #> NULL #>  #>  #> $ttp[[2]] #> $ttp[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.8065  -3.2682  -2.3448   0.2356 #> gamma1   0.8694   0.4668   1.2719   0.2054 #> gamma2  -0.0153  -0.0511   0.0205   0.0183 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.7298, df = 3 #> AIC = 849.4597 #>  #>  #> $ttp[[2]]$error #> NULL #>  #>  #> $ttp[[3]] #> $ttp[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.60314  -1.83224  -1.37404   0.11689 #> gamma1   0.38216   0.20690   0.55743   0.08942 #> gamma2  -0.01936  -0.03709  -0.00163   0.00905 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.5655, df = 3 #> AIC = 849.1309 #>  #>  #> $ttp[[3]]$error #> NULL #>  #>  #> $ttp[[4]] #> $ttp[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.73940  -3.27506  -2.20374   0.27330 #> gamma1   0.94983   0.43833   1.46132   0.26097 #> gamma2  -0.00852  -0.14684   0.12981   0.07058 #> gamma3   0.02978  -0.19567   0.25523   0.11503 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.8021, df = 4 #> AIC = 853.6043 #>  #>  #> $ttp[[4]]$error #> NULL #>  #>  #> $ttp[[5]] #> $ttp[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6568  -3.2134  -2.1003   0.2840 #> gamma1   1.0097   0.4700   1.5494   0.2754 #> gamma2   0.0691  -0.0964   0.2346   0.0844 #> gamma3  -0.1375  -0.4197   0.1448   0.1440 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3791, df = 4 #> AIC = 850.7583 #>  #>  #> $ttp[[5]]$error #> NULL #>  #>  #> $ttp[[6]] #> $ttp[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.5359  -1.8178  -1.2539   0.1439 #> gamma1   0.4345   0.2068   0.6622   0.1162 #> gamma2   0.0304  -0.0583   0.1190   0.0452 #> gamma3  -0.0796  -0.2359   0.0768   0.0798 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3112, df = 4 #> AIC = 850.6223 #>  #>  #> $ttp[[6]]$error #> NULL #>  #>  #> $ttp[[7]] #> $ttp[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est        L95%       U95%       se        #> gamma0  -2.485963  -3.046780  -1.925146   0.286136 #> gamma1   1.197935   0.554972   1.840897   0.328048 #> gamma2   0.221183   0.000965   0.441402   0.112358 #> gamma3  -0.837151  -1.573188  -0.101115   0.375536 #> gamma4   0.887201   0.107658   1.666745   0.397734 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.1814, df = 5 #> AIC = 850.3627 #>  #>  #> $ttp[[7]]$error #> NULL #>  #>  #> $ttp[[8]] #> $ttp[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.4671  -3.0582  -1.8759   0.3016 #> gamma1   1.1985   0.5475   1.8495   0.3322 #> gamma2   0.2335  -0.0137   0.4807   0.1261 #> gamma3  -0.7797  -1.6891   0.1296   0.4640 #> gamma4   0.7355  -0.2786   1.7496   0.5174 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.0042, df = 5 #> AIC = 850.0085 #>  #>  #> $ttp[[8]]$error #> NULL #>  #>  #> $ttp[[9]] #> $ttp[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.4492  -1.7515  -1.1470   0.1542 #> gamma1   0.5042   0.2406   0.7677   0.1345 #> gamma2   0.1192  -0.0130   0.2514   0.0674 #> gamma3  -0.4462  -0.9748   0.0824   0.2697 #> gamma4   0.4287  -0.1742   1.0316   0.3076 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.0067, df = 5 #> AIC = 850.0134 #>  #>  #> $ttp[[9]]$error #> NULL #>  #>  #>  #> $ppd #> $ppd[[1]] #> $ppd[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.8254  -7.7259  -3.9250   0.9696 #> gamma1   1.5623   0.4569   2.6676   0.5640 #> gamma2   0.0167  -0.1170   0.1504   0.0682 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7031, df = 3 #> AIC = 313.4063 #>  #>  #> $ppd[[1]]$error #> NULL #>  #>  #> $ppd[[2]] #> $ppd[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -5.79819  -7.70574  -3.89064   0.97326 #> gamma1   1.52049   0.39352   2.64745   0.57499 #> gamma2  -0.00446  -0.14762   0.13870   0.07304 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0731, df = 3 #> AIC = 314.1461 #>  #>  #> $ppd[[2]]$error #> NULL #>  #>  #> $ppd[[3]] #> $ppd[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7953  -3.4937  -2.0969   0.3563 #> gamma1   0.5645   0.1203   1.0088   0.2267 #> gamma2  -0.0331  -0.0986   0.0324   0.0334 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0678, df = 3 #> AIC = 314.1356 #>  #>  #> $ppd[[3]]$error #> NULL #>  #>  #> $ppd[[4]] #> $ppd[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.260  -8.623  -3.897   1.206 #> gamma1   2.080   0.308   3.851   0.904 #> gamma2   0.404  -0.502   1.309   0.462 #> gamma3  -0.433  -1.434   0.569   0.511 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.3264, df = 4 #> AIC = 314.6528 #>  #>  #> $ppd[[4]]$error #> NULL #>  #>  #> $ppd[[5]] #> $ppd[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.279  -8.668  -3.891   1.219 #> gamma1   2.108   0.301   3.916   0.922 #> gamma2   0.487  -0.491   1.465   0.499 #> gamma3  -0.560  -1.665   0.545   0.564 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5727, df = 4 #> AIC = 315.1455 #>  #>  #> $ppd[[5]]$error #> NULL #>  #>  #> $ppd[[6]] #> $ppd[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -2.920  -3.724  -2.115   0.410 #> gamma1   0.757   0.108   1.405   0.331 #> gamma2   0.207  -0.254   0.669   0.236 #> gamma3  -0.287  -0.839   0.266   0.282 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.6044, df = 4 #> AIC = 315.2088 #>  #>  #> $ppd[[6]]$error #> NULL #>  #>  #> $ppd[[7]] #> $ppd[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -6.3287  -8.9745  -3.6828   1.3500 #> gamma1   2.1917  -0.2408   4.6243   1.2411 #> gamma2   0.2345  -1.2647   1.7336   0.7649 #> gamma3   0.0531  -2.7172   2.8234   1.4134 #> gamma4  -0.3086  -2.3272   1.7101   1.0299 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.3243, df = 5 #> AIC = 316.6486 #>  #>  #> $ppd[[7]]$error #> NULL #>  #>  #> $ppd[[8]] #> $ppd[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.320  -8.969  -3.671   1.352 #> gamma1   2.182  -0.262   4.626   1.247 #> gamma2   0.223  -1.328   1.775   0.792 #> gamma3   0.174  -2.806   3.154   1.521 #> gamma4  -0.487  -2.746   1.772   1.153 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5704, df = 5 #> AIC = 317.1408 #>  #>  #> $ppd[[8]]$error #> NULL #>  #>  #> $ppd[[9]] #> $ppd[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.89719  -3.73120  -2.06319   0.42552 #> gamma1   0.71931  -0.08609   1.52472   0.41093 #> gamma2   0.00886  -0.65672   0.67443   0.33959 #> gamma3   0.24938  -1.22124   1.71999   0.75033 #> gamma4  -0.38355  -1.60015   0.83305   0.62073 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5862, df = 5 #> AIC = 317.1723 #>  #>  #> $ppd[[9]]$error #> NULL #>  #>  #>  #> $pfs #> $pfs[[1]] #> $pfs[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.71386  -3.13362  -2.29410   0.21417 #> gamma1   0.99398   0.61139   1.37657   0.19520 #> gamma2   0.00393  -0.01836   0.02622   0.01137 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0123, df = 3 #> AIC = 1030.025 #>  #>  #> $pfs[[1]]$error #> NULL #>  #>  #> $pfs[[2]] #> $pfs[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.84806  -3.29863  -2.39748   0.22989 #> gamma1   0.83234   0.44998   1.21469   0.19508 #> gamma2  -0.02545  -0.05136   0.00045   0.01322 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7148, df = 3 #> AIC = 1029.43 #>  #>  #> $pfs[[2]]$error #> NULL #>  #>  #> $pfs[[3]] #> $pfs[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.62401  -1.84681  -1.40122   0.11367 #> gamma1   0.37082   0.20155   0.54008   0.08636 #> gamma2  -0.02243  -0.03539  -0.00947   0.00661 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.4637, df = 3 #> AIC = 1028.927 #>  #>  #> $pfs[[3]]$error #> NULL #>  #>  #> $pfs[[4]] #> $pfs[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7744  -3.2640  -2.2848   0.2498 #> gamma1   0.9271   0.4496   1.4046   0.2436 #> gamma2  -0.0307  -0.1622   0.1007   0.0671 #> gamma3   0.0441  -0.1242   0.2124   0.0859 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.8845, df = 4 #> AIC = 1031.769 #>  #>  #> $pfs[[4]]$error #> NULL #>  #>  #> $pfs[[5]] #> $pfs[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7070  -3.2247  -2.1892   0.2642 #> gamma1   0.9774   0.4708   1.4841   0.2585 #> gamma2   0.0822  -0.0934   0.2577   0.0896 #> gamma3  -0.1403  -0.3780   0.0973   0.1212 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.2509, df = 4 #> AIC = 1030.502 #>  #>  #> $pfs[[5]]$error #> NULL #>  #>  #> $pfs[[6]] #> $pfs[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.5724  -1.8376  -1.3072   0.1353 #> gamma1   0.4129   0.1989   0.6270   0.1092 #> gamma2   0.0272  -0.0673   0.1217   0.0482 #> gamma3  -0.0637  -0.1942   0.0668   0.0666 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.2899, df = 4 #> AIC = 1030.58 #>  #>  #> $pfs[[6]]$error #> NULL #>  #>  #> $pfs[[7]] #> $pfs[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5410  -3.0589  -2.0230   0.2643 #> gamma1   1.1468   0.5511   1.7425   0.3040 #> gamma2   0.1899  -0.0306   0.4103   0.1125 #> gamma3  -0.7089  -1.3940  -0.0237   0.3496 #> gamma4   0.6196   0.0375   1.2017   0.2970 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -509.8239, df = 5 #> AIC = 1029.648 #>  #>  #> $pfs[[7]]$error #> NULL #>  #>  #> $pfs[[8]] #> $pfs[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5276  -3.0764  -1.9788   0.2800 #> gamma1   1.1501   0.5432   1.7569   0.3096 #> gamma2   0.2371  -0.0217   0.4958   0.1320 #> gamma3  -0.7336  -1.6565   0.1894   0.4709 #> gamma4   0.5475  -0.2960   1.3910   0.4303 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -510.0705, df = 5 #> AIC = 1030.141 #>  #>  #> $pfs[[8]]$error #> NULL #>  #>  #> $pfs[[9]] #> $pfs[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.4793  -1.7636  -1.1950   0.1450 #> gamma1   0.4844   0.2357   0.7330   0.1269 #> gamma2   0.1297  -0.0121   0.2716   0.0724 #> gamma3  -0.4727  -1.0114   0.0660   0.2749 #> gamma4   0.3763  -0.1221   0.8746   0.2543 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -509.868, df = 5 #> AIC = 1029.736 #>  #>  #> $pfs[[9]]$error #> NULL #>  #>  #>  #> $os #> $os[[1]] #> $os[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.0074  -6.2393  -3.7754   0.6286 #> gamma1   1.3996   0.7437   2.0556   0.3347 #> gamma2  -0.0157  -0.0995   0.0682   0.0428 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.2801, df = 3 #> AIC = 872.5603 #>  #>  #> $os[[1]]$error #> NULL #>  #>  #> $os[[2]] #> $os[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -4.8971  -6.1132  -3.6809   0.6205 #> gamma1   1.2418   0.5762   1.9075   0.3396 #> gamma2  -0.0854  -0.1808   0.0101   0.0487 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -435.5343, df = 3 #> AIC = 877.0686 #>  #>  #> $os[[2]]$error #> NULL #>  #>  #> $os[[3]] #> $os[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5243  -3.0238  -2.0248   0.2549 #> gamma1   0.5252   0.2308   0.8195   0.1502 #> gamma2  -0.0771  -0.1250  -0.0292   0.0245 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -434.7993, df = 3 #> AIC = 875.5985 #>  #>  #> $os[[3]]$error #> NULL #>  #>  #> $os[[4]] #> $os[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.321  -6.770  -3.872   0.739 #> gamma1   1.745   0.799   2.692   0.483 #> gamma2   0.299  -0.208   0.807   0.259 #> gamma3  -0.402  -1.050   0.246   0.331 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.5721, df = 4 #> AIC = 873.1442 #>  #>  #> $os[[4]]$error #> NULL #>  #>  #> $os[[5]] #> $os[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.369  -6.851  -3.886   0.757 #> gamma1   1.807   0.817   2.797   0.505 #> gamma2   0.614  -0.020   1.249   0.324 #> gamma3  -0.930  -1.784  -0.076   0.436 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.4306, df = 4 #> AIC = 874.8611 #>  #>  #> $os[[5]]$error #> NULL #>  #>  #> $os[[6]] #> $os[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6769  -3.2520  -2.1018   0.2934 #> gamma1   0.7502   0.3378   1.1625   0.2104 #> gamma2   0.3136  -0.0281   0.6553   0.1743 #> gamma3  -0.5287  -1.0036  -0.0538   0.2423 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.8091, df = 4 #> AIC = 873.6182 #>  #>  #> $os[[6]]$error #> NULL #>  #>  #> $os[[7]] #> $os[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.426  -6.984  -3.868   0.795 #> gamma1   1.879   0.738   3.019   0.582 #> gamma2   0.318  -0.573   1.209   0.455 #> gamma3  -0.275  -2.322   1.772   1.044 #> gamma4  -0.117  -1.820   1.587   0.869 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.4254, df = 5 #> AIC = 874.8508 #>  #>  #> $os[[7]]$error #> NULL #>  #>  #> $os[[8]] #> $os[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.4331  -7.0056  -3.8607   0.8023 #> gamma1   1.8919   0.7270   3.0569   0.5944 #> gamma2   0.3778  -0.6283   1.3839   0.5133 #> gamma3   0.0734  -2.4751   2.6219   1.3003 #> gamma4  -0.8477  -3.1699   1.4744   1.1848 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.2146, df = 5 #> AIC = 876.4292 #>  #>  #> $os[[8]]$error #> NULL #>  #>  #> $os[[9]] #> $os[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6970  -3.2959  -2.0981   0.3056 #> gamma1   0.7819   0.3067   1.2570   0.2424 #> gamma2   0.1897  -0.3455   0.7250   0.2731 #> gamma3   0.0191  -1.4401   1.4784   0.7446 #> gamma4  -0.4670  -1.8384   0.9043   0.6997 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.6368, df = 5 #> AIC = 875.2736 #>  #>  #> $os[[9]]$error #> NULL #>  #>  #>  #> $pps_cf #> $pps_cf[[1]] #> $pps_cf[[1]]$result #> NULL #>  #> $pps_cf[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[2]] #> $pps_cf[[2]]$result #> NULL #>  #> $pps_cf[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[3]] #> $pps_cf[[3]]$result #> NULL #>  #> $pps_cf[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[4]] #> $pps_cf[[4]]$result #> NULL #>  #> $pps_cf[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[5]] #> $pps_cf[[5]]$result #> NULL #>  #> $pps_cf[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[6]] #> $pps_cf[[6]]$result #> NULL #>  #> $pps_cf[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[7]] #> $pps_cf[[7]]$result #> NULL #>  #> $pps_cf[[7]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[8]] #> $pps_cf[[8]]$result #> NULL #>  #> $pps_cf[[8]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[9]] #> $pps_cf[[9]]$result #> NULL #>  #> $pps_cf[[9]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>  #> $pps_cr #> $pps_cr[[1]] #> $pps_cr[[1]]$result #> NULL #>  #> $pps_cr[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[2]] #> $pps_cr[[2]]$result #> NULL #>  #> $pps_cr[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[3]] #> $pps_cr[[3]]$result #> NULL #>  #> $pps_cr[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[4]] #> $pps_cr[[4]]$result #> NULL #>  #> $pps_cr[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[5]] #> $pps_cr[[5]]$result #> NULL #>  #> $pps_cr[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[6]] #> $pps_cr[[6]]$result #> NULL #>  #> $pps_cr[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[7]] #> $pps_cr[[7]]$result #> NULL #>  #> $pps_cr[[7]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[8]] #> $pps_cr[[8]]$result #> NULL #>  #> $pps_cr[[8]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[9]] #> $pps_cr[[9]]$result #> NULL #>  #> $pps_cr[[9]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>"},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit survival regressions with multiple splines or parametric distributions — fit_mods","title":"Fit survival regressions with multiple splines or parametric distributions — fit_mods","text":"Fit survival regressions multiple splines parametric distributions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit survival regressions with multiple splines or parametric distributions — fit_mods","text":"","code":"fit_mods(durn1, durn2 = NA, evflag, type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit survival regressions with multiple splines or parametric distributions — fit_mods","text":"durn1 Start time durn2 End time evflag Event flag type Type model (\"spl\" spline \"par\" parametric) spec Specification model","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit survival regressions with multiple splines or parametric distributions — fit_mods","text":"list distribution, containing two components: result: list containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit survival regressions with multiple parametric distributions — fit_mods_par","title":"Fit survival regressions with multiple parametric distributions — fit_mods_par","text":"Fits survival regressions flexsurv::flexsurvreg multiple statistical distributions one function call.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit survival regressions with multiple parametric distributions — fit_mods_par","text":"","code":"fit_mods_par(durn1, durn2 = NA, evflag, dists, expvar = NA)"},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit survival regressions with multiple parametric distributions — fit_mods_par","text":"durn1 First time point, corresponds time survival::Surv(). right censored data, follow time. interval data, first argument starting time interval. durn2 Second time point, corresponds time2 survival::Surv(). ending time interval interval censored counting process data . evflag Event flag, corresponds event survival::Surv. status indicator normally 0=alive, 1=dead. dists vector distributions (named according flexsurv::flexsurvreg()) statistical fits requested. expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit survival regressions with multiple parametric distributions — fit_mods_par","text":"list distribution, containing two components: result: list class flexsurv::flexsurvreg containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_spl.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit survival regressions with multiple spline regressions — fit_mods_spl","title":"Fit survival regressions with multiple spline regressions — fit_mods_spl","text":"Fits survival regressions flexsurv::flexsurvspline multiple Royston-Parmar splines specifications one function call.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_spl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit survival regressions with multiple spline regressions — fit_mods_spl","text":"","code":"fit_mods_spl(   durn1,   durn2 = NA,   evflag,   knot_set = 1:3,   scale_set = c(\"hazard\", \"odds\", \"normal\"),   expvar = NA )"},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_spl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit survival regressions with multiple spline regressions — fit_mods_spl","text":"durn1 First time point, corresponds time survival::Surv(). right censored data, follow time. interval data, first argument starting time interval. durn2 Second time point, corresponds time2 survival::Surv(). ending time interval interval censored counting process data . evflag Event flag, corresponds event survival::Surv. status indicator normally 0=alive, 1=dead. knot_set vector numbers knots consider, following flexsurv::flexsurvspline()). scale_set vector spline scales consider, following flexsurv::flexsurvspline()). expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_mods_spl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit survival regressions with multiple spline regressions — fit_mods_spl","text":"list distribution, containing two components: result: list class flexsurv::flexsurvspline containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of parameters used by parametric statistical distributions — give_noparams","title":"Number of parameters used by parametric statistical distributions — give_noparams","text":"Returns number parameters used specified statistical model","code":""},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of parameters used by parametric statistical distributions — give_noparams","text":"","code":"give_noparams(type, spec)"},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of parameters used by parametric statistical distributions — give_noparams","text":"type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of parameters used by parametric statistical distributions — give_noparams","text":"numeric value","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of parameters used by parametric statistical distributions — give_noparams","text":"","code":"give_noparams(type=\"par\", spec=list(dist=\"weibullPH\")) #> [1] 2 give_noparams(type=\"spl\", spec=list(gamma=c(1.1,2.1,3.1))) #> [1] 3"},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of parameters used by parametric statistical distributions — give_noparams_par","title":"Number of parameters used by parametric statistical distributions — give_noparams_par","text":"Returns number parameters used one many statistical distributions, named per flexsurv.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of parameters used by parametric statistical distributions — give_noparams_par","text":"","code":"give_noparams_par(dist)"},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of parameters used by parametric statistical distributions — give_noparams_par","text":"dist statistical distribution (named per flexsurv::flexsurvreg)","code":""},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of parameters used by parametric statistical distributions — give_noparams_par","text":"numeric value","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/give_noparams_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of parameters used by parametric statistical distributions — give_noparams_par","text":"","code":"give_noparams_par(\"llogis\") #> [1] 2"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the PSM hazard functions — graph_psm_hazards","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"Graph PSM hazard functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"","code":"graph_psm_hazards(timevar, endpoint, ptdata, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"timevar Vector times calculate hazards endpoint Endpoint hazard required (TTP, PPD, PFS, OS PPS) ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Type PSM - simple complex","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"adj hazard adjusted constraints, unadj unadjusted hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_par(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_par(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_par(fits$pfs, \"aic\")$fit,   os = find_bestfit_par(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_par(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_par(fits$pps_cr, \"aic\")$fit ) # Create graphics # psmh_simple <- graph_psm_hazards( #   timerange=(0:10)*6, #   endpoint=\"OS\", #   ptdata=bosonc, #   dpam=params, #   psmtype=\"simple\") # psmh_simple$graph"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the PSM survival functions — graph_psm_survs","title":"Graph the PSM survival functions — graph_psm_survs","text":"Graph PSM survival functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the PSM survival functions — graph_psm_survs","text":"","code":"graph_psm_survs(timevar, endpoint, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the PSM survival functions — graph_psm_survs","text":"timevar Vector times calculate hazards endpoint Endpoint hazard required (TTP, PPD, PFS, OS PPS) dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Type PSM - simple complex","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the PSM survival functions — graph_psm_survs","text":"adj hazard adjusted constraints, unadj unadjusted hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the PSM survival functions — graph_psm_survs","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_par(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_par(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_par(fits$pfs, \"aic\")$fit,   os = find_bestfit_par(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_par(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_par(fits$pps_cr, \"aic\")$fit ) # Original OS graphic graph_orig <- graph_survs(ptdata=bosonc, dpam=params) #> Creating KM  #> Calculating fitted curves  #> Rearranging datasets  #> Drawing plots  graph_orig$graph$os #> Warning: Removed 5 rows containing missing values or values outside the scale range #> (`geom_line()`).  # New graphic illustrating effect of constraints on OS model # psms_simple <- graph_psm_survs( # timerange=6*(0:10), # endpoint=\"OS\", # ptdata=bosonc, # dpam=params, # psmtype=\"simple\") # psms_simple$graph"},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the observed and fitted state membership probabilities — graph_survs","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"Graph observed fitted state membership probabilities PF, PD, OS PPS.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"","code":"graph_survs(ptdata, dpam, cuttime = 0, tpoints = 100)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime cut-time two-piece model (default 0, indicating one-piece model) tpoints indicates many timepoints included graphics (default 100)","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"Four datasets graphics list","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_par(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_par(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_par(fits$pfs, \"aic\")$fit,   os = find_bestfit_par(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_par(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_par(fits$pps_cr, \"aic\")$fit ) # Create graphics gs <- graph_survs(ptdata=bosonc, dpam=params) #> Creating KM  #> Calculating fitted curves  #> Rearranging datasets  #> Drawing plots  gs$graph$pd #> Warning: Removed 5 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://merck.github.io/psm3mkv/reference/pickout_psmhaz.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain adjusted and unadjusted PSM hazards — pickout_psmhaz","title":"Obtain adjusted and unadjusted PSM hazards — pickout_psmhaz","text":"EXPERIMENTAL. Obtain adjusted unadjusted PSM hazards given endpoint time","code":""},{"path":"https://merck.github.io/psm3mkv/reference/pickout_psmhaz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain adjusted and unadjusted PSM hazards — pickout_psmhaz","text":"","code":"pickout_psmhaz(timevar, endpoint = NA, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/pickout_psmhaz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain adjusted and unadjusted PSM hazards — pickout_psmhaz","text":"timevar Vector times calculate hazards endpoint Endpoint hazard required (TTP, PPD, PFS, OS PPS) dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Type PSM - simple complex","code":""},{"path":"https://merck.github.io/psm3mkv/reference/pickout_psmhaz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain adjusted and unadjusted PSM hazards — pickout_psmhaz","text":"adj hazard adjusted constraints, unadj unadjusted hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_os_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely calculate restricted mean duration for overall survival in the partitioned survival model — prmd_os_psm","title":"Safely calculate restricted mean duration for overall survival in the partitioned survival model — prmd_os_psm","text":"Calculates mean duration alive (.e. either progression free progressed disease states) partitioned survival model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate . Wrapper 'possibly' rmd_os_psm. function called calc_allrmds.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_os_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely calculate restricted mean duration for overall survival in the partitioned survival model — prmd_os_psm","text":"","code":"prmd_os_psm(...)"},{"path":"https://merck.github.io/psm3mkv/reference/prmd_os_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely calculate restricted mean duration for overall survival in the partitioned survival model — prmd_os_psm","text":"... Pass-rmd_os_psm","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_os_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely calculate restricted mean duration for overall survival in the partitioned survival model — prmd_os_psm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely calculate restricted mean duration in progressed disease state for clock forward state transition model — prmd_pd_stm_cf","title":"Safely calculate restricted mean duration in progressed disease state for clock forward state transition model — prmd_pd_stm_cf","text":"Calculates mean duration progressed disease state clock forward state transition model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate . Wrapper 'possibly' rmd_pd_stm_cf. function called calc_allrmds.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely calculate restricted mean duration in progressed disease state for clock forward state transition model — prmd_pd_stm_cf","text":"","code":"prmd_pd_stm_cf(...)"},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely calculate restricted mean duration in progressed disease state for clock forward state transition model — prmd_pd_stm_cf","text":"... Pass-rmd_pd_stm_cf","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely calculate restricted mean duration in progressed disease state for clock forward state transition model — prmd_pd_stm_cf","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely calculate restricted mean duration in progressed disease state for clock reset state transition model — prmd_pd_stm_cr","title":"Safely calculate restricted mean duration in progressed disease state for clock reset state transition model — prmd_pd_stm_cr","text":"Calculates mean duration progressed disease state clock reset state transition model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate . Wrapper 'possibly' rmd_pd_stm_cr. function called calc_allrmds.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely calculate restricted mean duration in progressed disease state for clock reset state transition model — prmd_pd_stm_cr","text":"","code":"prmd_pd_stm_cr(...)"},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely calculate restricted mean duration in progressed disease state for clock reset state transition model — prmd_pd_stm_cr","text":"... Pass-rmd_pd_stm_cr","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pd_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely calculate restricted mean duration in progressed disease state for clock reset state transition model — prmd_pd_stm_cr","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely calculate restricted mean duration in progression free state for the partitioned survival model — prmd_pf_psm","title":"Safely calculate restricted mean duration in progression free state for the partitioned survival model — prmd_pf_psm","text":"Calculates mean duration progression free state partitioned survival model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate . Wrapper 'possibly' rmd_pf_psm. function called calc_allrmds.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely calculate restricted mean duration in progression free state for the partitioned survival model — prmd_pf_psm","text":"","code":"prmd_pf_psm(...)"},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely calculate restricted mean duration in progression free state for the partitioned survival model — prmd_pf_psm","text":"... Pass-rmd_pf_psm","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely calculate restricted mean duration in progression free state for the partitioned survival model — prmd_pf_psm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_stm.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely calculate restricted mean duration in progression-free for state transition models — prmd_pf_stm","title":"Safely calculate restricted mean duration in progression-free for state transition models — prmd_pf_stm","text":"Calculates mean duration progression-free state state transition clock forward clock reset models. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate . Wrapper 'possibly' rmd_pf_stm. function called calc_allrmds.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_stm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely calculate restricted mean duration in progression-free for state transition models — prmd_pf_stm","text":"","code":"prmd_pf_stm(...)"},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_stm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely calculate restricted mean duration in progression-free for state transition models — prmd_pf_stm","text":"... Pass-rmd_pf_stm","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prmd_pf_stm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely calculate restricted mean duration in progression-free for state transition models — prmd_pf_stm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"Calculates membership probability alive particular time (vectorized), given either state transition model (clock forward clock reset) given statistical distributions parameters. sum membership probabilities progression free progressed disease states.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"","code":"prob_os_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include overall survival (OS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_os_psm(0:100, params) #>   [1] 1.000000000 0.993333811 0.982460429 0.969074887 0.953734324 0.936776991 #>   [7] 0.918449615 0.898950119 0.878446448 0.857086233 0.835002270 0.812315818 #>  [13] 0.789138714 0.765574757 0.741720655 0.717667076 0.693502704 0.669312345 #>  [19] 0.645174506 0.621161570 0.597339994 0.573770507 0.550508301 0.527603233 #>  [25] 0.505100023 0.483038462 0.461453625 0.440376084 0.419832131 0.399843999 #>  [31] 0.380430085 0.361605177 0.343380677 0.325764826 0.308762924 0.292377547 #>  [37] 0.276608761 0.261454330 0.246909917 0.232969284 0.219624475 0.206866001 #>  [43] 0.194683013 0.183063466 0.171994277 0.161461472 0.151450328 0.141945500 #>  [49] 0.132931146 0.124391040 0.116308675 0.108667364 0.101450325 0.094640765 #>  [55] 0.088221917 0.082177105 0.076489851 0.071143939 0.066123454 0.061412820 #>  [61] 0.056996834 0.052860693 0.048990017 0.045370867 0.041989763 0.038833690 #>  [67] 0.035890110 0.033146965 0.030592679 0.028216158 0.026006789 0.023954430 #>  [73] 0.022049410 0.020282517 0.018644991 0.017128511 0.015725185 0.014427539 #>  [79] 0.013228500 0.012121389 0.011099902 0.010158095 0.009290377 0.008491485 #>  [85] 0.007756480 0.007080727 0.006459880 0.005889871 0.005366897 0.004887403 #>  [91] 0.004448071 0.004045807 0.003677730 0.003341156 0.003033593 0.002752723 #>  [97] 0.002496397 0.002262621 0.002049549 0.001855470 0.001678803"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"Calculates membership probability alive given time (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"","code":"prob_os_stm_cf(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock forward model (PPS-CF). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_os_stm_cf(0:100, params) #>   [1] 1.00000000 0.99438187 0.98388723 0.97045962 0.95480239 0.93736449 #>   [7] 0.91847520 0.89839291 0.87733215 0.85547549 0.83298470 0.81000158 #>  [13] 0.78664786 0.76303528 0.73926205 0.71541805 0.69158476 0.66783743 #>  [19] 0.64424475 0.62087956 0.59781713 0.57511174 0.55281670 0.53097889 #>  [25] 0.50963525 0.48881683 0.46854870 0.44885041 0.42973671 0.41121802 #>  [31] 0.39330081 0.37598800 0.35927948 0.34317249 0.32766172 0.31273990 #>  [37] 0.29839789 0.28462513 0.27140962 0.25873850 0.24659790 0.23497329 #>  [43] 0.22384963 0.21321146 0.20304335 0.19332892 0.18405247 0.17519810 #>  [49] 0.16675002 0.15869261 0.15101046 0.14370296 0.13672548 0.13007897 #>  [55] 0.12374922 0.11772229 0.11197405 0.10651346 0.10131630 0.09637071 #>  [61] 0.09166506 0.08718819 0.08292942 0.07887846 0.07502548 0.07136107 #>  [67] 0.06787620 0.06456226 0.06141100 0.05841457 0.05556543 0.05285661 #>  [73] 0.05028089 0.04783192 0.04550350 0.04328969 0.04118485 0.03918361 #>  [79] 0.03728177 0.03547254 0.03375228 0.03211658 0.03056125 0.02908229 #>  [85] 0.02767592 0.02633852 0.02506668 0.02385712 0.02270676 0.02161266 #>  [91] 0.02057201 0.01958217 0.01864061 0.01774527 0.01689317 0.01608253 #>  [97] 0.01531128 0.01457750 0.01387931 0.01321495 0.01258276"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"Calculates membership probability alive given time (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"","code":"prob_os_stm_cr(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock reset model (PPS-CR). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_os_stm_cr(0:100, params) #>   [1] 1.00000000 0.99695476 0.98950782 0.97746752 0.96161310 0.94299857 #>   [7] 0.92254723 0.90090563 0.87846191 0.85545262 0.83203515 0.80832010 #>  [13] 0.78438687 0.76030439 0.73614308 0.71198223 0.68790283 0.66398489 #>  [19] 0.64030304 0.61692553 0.59392015 0.57133517 0.54921944 0.52761537 #>  [25] 0.50655596 0.48606814 0.46617256 0.44688418 0.42821302 0.41016450 #>  [31] 0.39274008 0.37593750 0.35975163 0.34417487 0.32919723 0.31480714 #>  [37] 0.30099142 0.28773575 0.27502473 0.26284252 0.25117260 0.23999818 #>  [43] 0.22930225 0.21906785 0.20927831 0.19991639 0.19096573 0.18241001 #>  [49] 0.17423324 0.16643504 0.15896917 0.15183686 0.14502391 0.13850405 #>  [55] 0.13228962 0.12635463 0.12068691 0.11527456 0.11010623 0.10517103 #>  [61] 0.10045851 0.09595866 0.09166190 0.08755905 0.08364158 0.07990060 #>  [67] 0.07632835 0.07291716 0.06965971 0.06654902 0.06357815 0.06074126 #>  [73] 0.05803193 0.05544476 0.05297372 0.05061357 0.04835939 0.04620636 #>  [79] 0.04414988 0.04218558 0.04031110 0.03851873 0.03680657 0.03517099 #>  [85] 0.03360852 0.03211587 0.03068988 0.02932754 0.02802600 0.02678250 #>  [91] 0.02559444 0.02445933 0.02337478 0.02233852 0.02134838 0.02040230 #>  [97] 0.01949830 0.01863449 0.01780908 0.01702035 0.01626666"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"Calculates membership probability progressed disease particular time (vectorized), given partitioned survival model certain statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"","code":"prob_pd_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include progression-free survival (PFS) overall survival (OS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pd_psm(0:100, params) #>   [1]  0.000000000  0.054213562  0.098565251  0.137013060  0.170266758 #>   [6]  0.198796057  0.223008955  0.243280274  0.259955242  0.273308351 #>  [11]  0.283582761  0.291034994  0.295922768  0.298496989  0.298997351 #>  [16]  0.297650474  0.294672507  0.290266681  0.284620862  0.277908013 #>  [21]  0.270286856  0.261902614  0.252887788  0.243362937  0.233437439 #>  [26]  0.223210226  0.212770498  0.202198385  0.191565592  0.180935996 #>  [31]  0.170366221  0.159906170  0.149599537  0.139484288  0.129593106 #>  [36]  0.119953824  0.110589822  0.101520409  0.092761177  0.084324333 #>  [41]  0.076219022  0.068451612  0.061025979  0.053943759  0.047204597 #>  [46]  0.040806365  0.034745377  0.029016580  0.023613739  0.018529600 #>  [51]  0.013756110  0.009284544  0.005105561  0.001209324 -0.002414425 #>  [56] -0.005776271 -0.008886978 -0.011757406 -0.014398443 -0.016820940 #>  [61] -0.019035660 -0.021053227 -0.022884090 -0.024538479 -0.026026384 #>  [66] -0.027357522 -0.028541320 -0.029586897 -0.030503052 -0.031298251 #>  [71] -0.031980622 -0.032557951 -0.033037680 -0.033426907 -0.033732387 #>  [76] -0.033960539 -0.034117447 -0.034208871 -0.034240252 -0.034216719 #>  [81] -0.034143102 -0.034023939 -0.033863488 -0.033665734 -0.033434406 #>  [86] -0.033172981 -0.032884702 -0.032572583 -0.032239423 -0.031887818 #>  [91] -0.031520167 -0.031138688 -0.030745425 -0.030342259 -0.029930916 #>  [96] -0.029512981 -0.029089899 -0.028662992 -0.028233462 -0.027802399 #> [101] -0.027370792"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"Calculates membership probability progressed disease state given time (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"","code":"prob_pd_stm_cf(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock forward model (PPS-CF). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pd_stm_cf(0:100, params) #>   [1] 0.000000000 0.057565843 0.102501319 0.140011833 0.171674410 0.198397032 #>   [7] 0.220826251 0.239465829 0.254684897 0.266784588 0.276064470 0.282811290 #>  [13] 0.287292879 0.289760924 0.290444507 0.289554760 0.287284771 0.283812230 #>  [19] 0.279299653 0.273905726 0.267784327 0.261061641 0.253856894 0.246277388 #>  [25] 0.238415524 0.230353913 0.222165759 0.213914700 0.205655880 0.197436766 #>  [31] 0.189297938 0.181273752 0.173393123 0.165680168 0.158154467 0.150831878 #>  [37] 0.143724753 0.136842555 0.130191950 0.123777527 0.117601707 0.111665238 #>  [43] 0.105967356 0.100506051 0.095278476 0.090280111 0.085506406 0.080951979 #>  [49] 0.076610924 0.072476967 0.068543515 0.064818251 0.061264396 0.057890339 #>  [55] 0.054688924 0.051652873 0.048764410 0.046038487 0.043456604 0.041012315 #>  [61] 0.038699151 0.036510856 0.034441387 0.032484908 0.030635803 0.028888675 #>  [67] 0.027238338 0.025679816 0.024208354 0.022819395 0.021508584 0.020271953 #>  [73] 0.019105157 0.018004616 0.016966732 0.015988084 0.015065419 0.014195646 #>  [79] 0.013376758 0.012604047 0.011875869 0.011189720 0.010543227 0.009934145 #>  [85] 0.009360347 0.008819822 0.008310665 0.007831078 0.007379362 0.006953909 #>  [91] 0.006553202 0.006175811 0.005820382 0.005485971 0.005170675 0.004873730 #>  [97] 0.004594067 0.004330694 0.004082633 0.003848996 0.003628937"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"Calculates membership probability progressed disease state given time (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"","code":"prob_pd_stm_cr(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock reset model (PPS-CR). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pd_stm_cr(0:100, params) #>   [1] 0.000000000 0.060138735 0.108121914 0.147019738 0.178485112 0.204031115 #>   [7] 0.224898274 0.241978542 0.255814655 0.266761717 0.275114914 0.281129804 #>  [13] 0.285031884 0.287030029 0.287325545 0.286118938 0.283602846 0.279959691 #>  [19] 0.275357940 0.269951702 0.263887342 0.257285072 0.250259636 0.242913869 #>  [25] 0.235336236 0.227605222 0.219789614 0.211948479 0.204132184 0.196383250 #>  [31] 0.188737209 0.181223250 0.173865274 0.166682547 0.159689972 0.152899110 #>  [37] 0.146318278 0.139953175 0.133807059 0.127881545 0.122176413 0.116690118 #>  [43] 0.111419978 0.106362436 0.101513431 0.096867583 0.092419669 0.088163888 #>  [49] 0.084094142 0.080219398 0.076502228 0.072952148 0.069562820 0.066315417 #>  [55] 0.063229318 0.060285215 0.057477267 0.054799591 0.052246535 0.049812641 #>  [61] 0.047492604 0.045281319 0.043173866 0.041165500 0.039251895 0.037428207 #>  [67] 0.035690487 0.034034715 0.032457061 0.030953852 0.029521303 0.028156597 #>  [73] 0.026856198 0.025617453 0.024436951 0.023311968 0.022239959 0.021218396 #>  [79] 0.020244868 0.019317084 0.018434681 0.017591864 0.016788545 0.016022838 #>  [85] 0.015292949 0.014597168 0.013933868 0.013301503 0.012698600 0.012123756 #>  [91] 0.011575636 0.011052971 0.010554551 0.010079221 0.009625886 0.009193506 #>  [97] 0.008781088 0.008387688 0.008012409 0.007654395 0.007312832"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"Calculates membership probability progression free state, particular time (vectorized), given partitioned survival model given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"","code":"prob_pf_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include progression-free survival (PFS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pf_psm(0:100, params) #>   [1] 1.00000000 0.93912025 0.88389518 0.83206183 0.78346757 0.73798093 #>   [7] 0.69544066 0.65566985 0.61849121 0.58377788 0.55141951 0.52128082 #>  [13] 0.49321595 0.46707777 0.44272330 0.42001660 0.39883020 0.37904566 #>  [19] 0.36055364 0.34325356 0.32705314 0.31186789 0.29762051 0.28424030 #>  [25] 0.27166258 0.25982824 0.24868313 0.23817770 0.22826654 0.21890800 #>  [31] 0.21006386 0.20169901 0.19378114 0.18628054 0.17916982 0.17242372 #>  [37] 0.16601894 0.15993392 0.15414874 0.14864495 0.14340545 0.13841439 #>  [43] 0.13365703 0.12911971 0.12478968 0.12065511 0.11670495 0.11292892 #>  [49] 0.10931741 0.10586144 0.10255257 0.09938282 0.09634476 0.09343144 #>  [55] 0.09063634 0.08795338 0.08537683 0.08290135 0.08052190 0.07823376 #>  [61] 0.07603249 0.07391392 0.07187411 0.06990935 0.06801615 0.06619121 #>  [67] 0.06443143 0.06273386 0.06109573 0.05951441 0.05798741 0.05651238 #>  [73] 0.05508709 0.05370942 0.05237738 0.05108905 0.04984263 0.04863641 #>  [79] 0.04746875 0.04633811 0.04524300 0.04418203 0.04315386 0.04215722 #>  [85] 0.04119089 0.04025371 0.03934458 0.03846245 0.03760632 0.03677522 #>  [91] 0.03596824 0.03518449 0.03442315 0.03368341 0.03296451 0.03226570 #>  [97] 0.03158630 0.03092561 0.03028301 0.02965787 0.02904960"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"Calculates membership probability progression free state, particular time (vectorized), given either state transition model (clock forward clock reset) given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"","code":"prob_pf_stm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include pre-progression death (PPD) time progression (TTP). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pf_stm(0:100, params) #>   [1] 1.000000000 0.936816026 0.881385907 0.830447785 0.783127984 0.738967456 #>   [7] 0.697648951 0.658927085 0.622647253 0.588690906 0.556920232 0.527190295 #>  [13] 0.499354983 0.473274361 0.448817539 0.425863288 0.404299985 0.384025196 #>  [19] 0.364945100 0.346973830 0.330032807 0.314050098 0.298959805 0.284701505 #>  [25] 0.271219725 0.258462919 0.246382941 0.234935706 0.224080833 0.213781255 #>  [31] 0.204002873 0.194714251 0.185886357 0.177492325 0.169507255 0.161908026 #>  [37] 0.154673141 0.147782578 0.141217667 0.134960971 0.128996189 0.123308057 #>  [43] 0.117882272 0.112705414 0.107764877 0.103048810 0.098546060 0.094246124 #>  [49] 0.090139098 0.086215640 0.082466945 0.078884713 0.075461087 0.072188631 #>  [55] 0.069060301 0.066069417 0.063209645 0.060474974 0.057859696 0.055358390 #>  [61] 0.052965904 0.050677338 0.048488033 0.046393554 0.044389680 0.042472393 #>  [67] 0.040637862 0.038882440 0.037202649 0.035595173 0.034056849 0.032584661 #>  [73] 0.031175728 0.029827304 0.028536765 0.027301606 0.026119435 0.024987966 #>  [79] 0.023905015 0.022868496 0.021876415 0.020926865 0.020018024 0.019148149 #>  [85] 0.018315572 0.017518701 0.016756010 0.016026041 0.015327399 0.014658747 #>  [91] 0.014018808 0.013406359 0.012820230 0.012259301 0.011722498 0.011208797 #>  [97] 0.010717213 0.010246806 0.009796674 0.009365957 0.008953827"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"Calculates probability post progression survival given time progression (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"","code":"prob_pps_cf(ttptimes, ppstimes, dpam)"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"ttptimes Time (numeric vectorized) progression - time baseline. ppstimes Time (numeric vectorized) progression dpam List survival regressions model endpoints. must include post progression survival calculated clock forward state transition model.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"Vector mean probabilities post-progression survival PPS time, averaged TTP times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pps_cf(0:100, 0:100, params) #>   [1] 1.0000000000 0.9269277329 0.8595239740 0.7969376513 0.7387652556 #>   [6] 0.6846798786 0.6343928456 0.5876418128 0.5441853505 0.5037998452 #>  [11] 0.4662774338 0.4314244718 0.3990603131 0.3690162875 0.3411348163 #>  [16] 0.3152686285 0.2912800553 0.2690403877 0.2484292861 0.2293342129 #>  [21] 0.2116498123 0.1952774482 0.1801248358 0.1661056875 0.1531393715 #>  [26] 0.1411505858 0.1300690452 0.1198291833 0.1103698686 0.1016341336 #>  [31] 0.0935689188 0.0861248289 0.0792559018 0.0729193903 0.0670755557 #>  [36] 0.0616874726 0.0567208450 0.0521438326 0.0479268878 0.0440426013 #>  [41] 0.0404655582 0.0371722017 0.0341407061 0.0313508565 0.0287839376 #>  [46] 0.0264226280 0.0242509024 0.0222539395 0.0204180363 0.0187305277 #>  [51] 0.0171797114 0.0157547788 0.0144457490 0.0132434086 0.0121392552 #>  [56] 0.0111254450 0.0101947448 0.0093404857 0.0085565206 0.0078371848 #>  [61] 0.0071772589 0.0065719348 0.0060167848 0.0055077315 0.0050410215 #>  [66] 0.0046132003 0.0042210887 0.0038617618 0.0035325292 0.0032309164 #>  [71] 0.0029546483 0.0027016332 0.0024699484 0.0022578272 0.0020636461 #>  [76] 0.0018859137 0.0017232603 0.0015744280 0.0014382617 0.0013137012 #>  [81] 0.0011997733 0.0010955850 0.0010003168 0.0009132171 0.0008335964 #>  [86] 0.0007608223 0.0006943151 0.0006335432 0.0005780195 0.0005272975 #>  [91] 0.0004809679 0.0004386560 0.0004000183 0.0003647404 0.0003325341 #>  [96] 0.0003031359 0.0002763042 0.0002518181 0.0002294753 0.0002090907 #> [101] 0.0001904951"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"Calculates probability post progression survival given time progression (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"","code":"prob_pps_cr(time, dpam)"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"time Time (numeric vectorized) baseline - time progression. dpam List survival regressions model endpoints. must include post progression survival calculated clock reset state transition model.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) prob_pps_cr(0:100, params) #>   [1] 1.000000000 0.987105716 0.934461106 0.868401686 0.806475394 0.753434376 #>   [7] 0.708946460 0.669965664 0.634136012 0.600110241 0.567138271 0.534824586 #>  [13] 0.502988745 0.471688904 0.441242337 0.411907557 0.383860425 0.357212477 #>  [19] 0.332025219 0.308321522 0.286094792 0.265316380 0.245941526 0.227914131 #>  [25] 0.211170533 0.195642481 0.181259439 0.167950356 0.155644991 0.144274888 #>  [31] 0.133774071 0.124079519 0.115131461 0.106873544 0.099252896 0.092220108 #>  [37] 0.085729164 0.079737331 0.074205016 0.069095609 0.064375317 0.060012987 #>  [43] 0.055979934 0.052249773 0.048798245 0.045602808 0.042642502 0.039898200 #>  [49] 0.037352466 0.034989399 0.032794482 0.030754457 0.028857209 0.027091656 #>  [55] 0.025447658 0.023915928 0.022487958 0.021155944 0.019912726 0.018751730 #>  [61] 0.017666915 0.016652728 0.015704061 0.014816209 0.013984840 0.013205960 #>  [67] 0.012475887 0.011791221 0.011148823 0.010545793 0.009979448 0.009447308 #>  [73] 0.008947078 0.008476629 0.008033991 0.007617337 0.007224971 0.006855320 #>  [79] 0.006506923 0.006178421 0.005868551 0.005576140 0.005300095 0.005039397 #>  [85] 0.004793098 0.004560316 0.004340227 0.004132060 0.003935100 0.003748675 #>  [91] 0.003572161 0.003404972 0.003246561 0.003096416 0.002954059 0.002819042 #>  [97] 0.002690943 0.002569370 0.002453954 0.002344348 0.002240229"},{"path":"https://merck.github.io/psm3mkv/reference/psm3mkv-package.html","id":null,"dir":"Reference","previous_headings":"","what":"psm3mkv: Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data — psm3mkv-package","title":"psm3mkv: Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data — psm3mkv-package","text":"Fits evaluates three-state partitioned survival analyses (PartSAs) markov models (clock forward clock reset) Progression-Free Survival (PFS) Overall Survival (OS) patient-level data. data typically collected clinical trials oncology. model structures typically considered cost-effectiveness modeling advanced/metastatic cancer indications.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/psm3mkv-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"psm3mkv: Fit and Evaluate Three-State Partitioned Survival Analysis and Markov Models to Progression-Free and Overall Survival Data — psm3mkv-package","text":"Maintainer: Dominic Muston dominic.muston@merck.com (ORCID) contributors: Merck & Co., Inc. [copyright holder, funder]","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_os_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","title":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","text":"Calculates mean duration alive (.e. either progression free progressed disease states) partitioned survival model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_os_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","text":"","code":"rmd_os_psm(dpam, Ty = 10, starting = c(1, 0, 0), discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_os_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. starting Vector membership probabilities time zero. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_os_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/rmd_os_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restricted mean duration for overall survival in the partitioned survival model — rmd_os_psm","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) rmd_os_psm(params) #> [1] 27.44252"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","title":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","text":"Calculates mean duration progressed disease state clock forward state transition model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","text":"","code":"rmd_pd_stm_cf(dpam, Ty = 10, starting = c(1, 0, 0), discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. starting Vector membership probabilities time zero. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restricted mean duration in progressed disease state for clock forward state transition model — rmd_pd_stm_cf","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) # Find mean(s) rmd_pd_stm_cf(dpam=params) #> [1] 10.53941"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","title":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","text":"Calculates mean duration progressed disease state clock reset state transition model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","text":"","code":"rmd_pd_stm_cr(dpam, Ty = 10, starting = c(1, 0, 0), discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. starting Vector membership probabilities time zero. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pd_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restricted mean duration in progressed disease state for clock reset state transition model — rmd_pd_stm_cr","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) rmd_pd_stm_cr(dpam=params) #> [1] 11.05169"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","title":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","text":"Calculates mean duration progression free state partitioned survival model. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","text":"","code":"rmd_pf_psm(dpam, Ty = 10, starting = c(1, 0, 0), discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. starting Vector membership probabilities time zero. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restricted mean duration in progression free state for the partitioned survival model — rmd_pf_psm","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) # Find mean(s) rmd_pf_psm(dpam=params) #> [1] 22.02965"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_stm.html","id":null,"dir":"Reference","previous_headings":"","what":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","title":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","text":"Calculates mean duration progression-free state state transition clock forward clock reset models. Requires carefully formatted list fitted survival regressions necessary endpoints, time duration calculate .","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_stm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","text":"","code":"rmd_pf_stm(dpam, Ty = 10, starting = c(1, 0, 0), discrate = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_stm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","text":"dpam List survival regressions model endpoints. must include time progression (TTP) pre-progression death (PPD). Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. starting Vector membership probabilities time zero. discrate Discount rate (%) per year","code":""},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_stm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","text":"Numeric value time unit patient-level data (weeks).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/rmd_pf_stm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restricted mean duration in progression-free for state transition models — rmd_pf_stm","text":"","code":"# Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit_spl(fits$ppd, \"aic\")$fit,   ttp = find_bestfit_spl(fits$ttp, \"aic\")$fit,   pfs = find_bestfit_spl(fits$pfs, \"aic\")$fit,   os = find_bestfit_spl(fits$os, \"aic\")$fit,   pps_cf = find_bestfit_spl(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit_spl(fits$pps_cr, \"aic\")$fit ) rmd_pf_stm(dpam=params) #> [1] 18.97163"},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":null,"dir":"Reference","previous_headings":"","what":"VLOOKUP function — vlookup","title":"VLOOKUP function — vlookup","text":"Function lookup values according index. Aims behave similarly VLOOKUP Microsoft Excel.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VLOOKUP function — vlookup","text":"","code":"vlookup(indexval, indexvec, valvec, method = \"geom\")"},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VLOOKUP function — vlookup","text":"indexval index value looked-(may vector multiple values) indexvec vector indices look-valvec vector values corresponding vector indices method Method may floor, ceiling, arith geom (default).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"VLOOKUP function — vlookup","text":"Numeric value vector, depending lookup/interpolation method chosen: floor: Floor value, interpolation required measured values ceiling: Ceiling value, interpolation required measured values arith: Arithmetic mean, interpolation required measured values geom: Geometric mean, interpolation required measured values","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"VLOOKUP function — vlookup","text":"","code":"# Suppose we have survival probabilities at times 0 to 20 times <- 0:20 survival <- 1-times*0.04 # We would like to look-up the survival probability at time 7 vlookup(7, times, survival) #> [1] 0.72 # In this case, the floor, ceiling, arith and geom values are identical # because survival time 7 is known, and no interpolation is necessary vlookup(c(7, 7.5), times, survival) #> [1] 0.7200000 0.6997142 # The second row of the returned tibble reveal different estimates of the survival at time 7.5. # The values vary according to the interpolation method between # observed survival values at times 7 and 8."},{"path":"https://merck.github.io/psm3mkv/reference/vonelookup.html","id":null,"dir":"Reference","previous_headings":"","what":"VoneLOOKUP function — vonelookup","title":"VoneLOOKUP function — vonelookup","text":"Function lookup single (one) value according index. Aims behave similarly VLOOKUP Microsoft Excel.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vonelookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VoneLOOKUP function — vonelookup","text":"","code":"vonelookup(oneindexval, indexvec, valvec, method = \"geom\")"},{"path":"https://merck.github.io/psm3mkv/reference/vonelookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VoneLOOKUP function — vonelookup","text":"oneindexval single index value looked-indexvec vector indices look-valvec vector values corresponding vector indices method Method may floor, ceiling, arith geom (default).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vonelookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"VoneLOOKUP function — vonelookup","text":"Numeric value vector, depending lookup/interpolation method chosen: floor: Floor value, interpolation required measured values ceiling: Ceiling value, interpolation required measured values arith: Arithmetic mean, interpolation required measured values geom: Geometric mean, interpolation required measured values","code":""},{"path":[]},{"path":[]},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"id_14-apr-2024---version-021","dir":"Changelog","previous_headings":"","what":"14 Apr 2024 - Version 0.2.1","title":"14 Apr 2024 - Version 0.2.1","text":"Constraining calculations restricted mean durations accompanying vignette(\"background-mortality\") reworked. calculations using integral/continuous methods reliable. Instead, calc_allrmds now rmdmethod=\"disc\" option allow discretized calculations given timestep (defaulting one week). new collection functions discrmd.R provide , well constrain_survprob() function, constrains vector survival estimates given times underlying hazard least great accompanying lifetable.","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"id_26-jan-2024---version-02","dir":"Changelog","previous_headings":"","what":"26 Jan 2024 - Version 0.2","title":"26 Jan 2024 - Version 0.2","text":"version provides additional functionality calculation restricted mean durations calc_allrmds. estimates may now constrained lifetable (see calc_ltsurv) discounting may now applied. vignette describing use functionality provided: vignette(\"background-mortality\"). also changes _pkgdown.yml avoid theming changes imposed 0.6.0 release bslib 0.6.0, thanks @nanxstats.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"added-psm-analysis-functions-experimental-0-1-1","dir":"Changelog","previous_headings":"","what":"Added PSM analysis functions (experimental)","title":"5 Jan 2024 - Version 0.1.1","text":"’ve merged experimental functions main branch following version 0.1 release package. functions provide analyses constraints mortality hazards therefore survival implied PSM. : calc_haz_psm(), calc_surv_psmpps(), pickout_psmhaz, graph_psm_hazards(), graph_psm_survs().","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"id_1-jan-2024---version-01","dir":"Changelog","previous_headings":"","what":"1 Jan 2024 - Version 0.1","title":"1 Jan 2024 - Version 0.1","text":"initial release package, rather belatedly. code dates October 2023.","code":""}]
