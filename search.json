[{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://merck.github.io/psm3mkv/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"Copyright © 2024 Merck & Co., Inc., Rahway, NJ, USA and its affiliates. All rights reserved.  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example use of psm3mkv","text":"vignette walks evaluating partitioned survival model (PSM) state transition model structures (either clock reset, STM-CR, clock forward types, STM-CF) dataset derived bosms3 dataset comes flexsurv package (Jackson 2016). review PSMs STMs oncology cost-effectiveness models provided Woods et al. (2020). First need load packages interest. haven’t installed psm3mkv yet, please see installation instructions install dependencies. also using Angelo Canty B. D. Ripley (2024), Xiao (2024) Wickham Henry (2023).","code":"library(\"boot\") library(\"ggsci\") #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(\"psm3mkv\") library(\"purrr\")"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"obtaining-a-suitable-dataset","dir":"Articles","previous_headings":"","what":"Obtaining a suitable dataset","title":"Example use of psm3mkv","text":"First create suitable patient-level dataset using create_dummydata(). load data derived bosms3 dataset flexsurv package (Jackson 2016). dataset contains TTP, PFS OS data 204 patients.","code":"# Create and review the dummy dataset bosonc <- create_dummydata(\"flexbosms\") head(bosonc) #> # A tibble: 6 × 7 #>    ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag #>   <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl> #> 1     1   18.7          1   42.9        1   18.7          1 #> 2     2   12.0          1   23.3        1   12.0          1 #> 3     3    0.452        1    8.81       1    0.452        1 #> 4     4    9.07         1   52.7        1    9.07         1 #> 5     5   47.7          0   47.7        0   47.7          0 #> 6     6    3.26         1   13.1        1    3.26         1 summary(bosonc) #>       ptid           pfs.durn          pfs.flag         os.durn       #>  Min.   :  1.00   Min.   : 0.1071   Min.   :0.0000   Min.   : 0.881   #>  1st Qu.: 51.75   1st Qu.: 4.2381   1st Qu.:0.0000   1st Qu.: 7.893   #>  Median :102.50   Median : 9.7262   Median :1.0000   Median :15.226   #>  Mean   :102.50   Mean   :11.5630   Mean   :0.6471   Mean   :17.055   #>  3rd Qu.:153.25   3rd Qu.:16.2321   3rd Qu.:1.0000   3rd Qu.:22.729   #>  Max.   :204.00   Max.   :48.5357   Max.   :1.0000   Max.   :52.702   #>     os.flag          ttp.durn          ttp.flag      #>  Min.   :0.0000   Min.   : 0.1071   Min.   :0.0000   #>  1st Qu.:0.0000   1st Qu.: 4.2381   1st Qu.:0.0000   #>  Median :0.0000   Median : 9.7262   Median :1.0000   #>  Mean   :0.4755   Mean   :11.5630   Mean   :0.5049   #>  3rd Qu.:1.0000   3rd Qu.:16.2321   3rd Qu.:1.0000   #>  Max.   :1.0000   Max.   :48.5357   Max.   :1.0000"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"fit-survival-curves-to-the-relevant-endpoints","dir":"Articles","previous_headings":"","what":"Fit survival curves to the relevant endpoints","title":"Example use of psm3mkv","text":"three cost-effectiveness model structures considering rely modeling PFS, TTP OS, additionally three endpoints: Pre-progression death (PPD). Post progression survival function time baseline (known ‘clock forward’, PPS-CF). Post-progression survival function time progression (known ‘clock reset’, PPS-CR). suitable dataset, fit statistical models six endpoints.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"parametric-distributions","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Parametric distributions","title":"Example use of psm3mkv","text":"Let us start considering parametric distributions. uses function fit_ends_mods(), called cycles fitting endpoints models. original dataset contained three endpoints, three endpoints calculated within function. fitted multiple parametric distributions endpoint. need retain best-fitting distribution, select using find_bestfit_par() basis distribution lowest Akaike Information Criterion (AIC).","code":"# Create a vector of distributions of interest (flexsurv notation) alldists <- c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\", \"gengamma\")  # Fit all distributions to all endpoints (except gengamma to PPD and TTP) allfits_par <- fit_ends_mods_par(   bosonc,   cuttime = 0,   ppd.dist = alldists[1:6],   ttp.dist = alldists[1:6],   pfs.dist = alldists,   os.dist = alldists,   pps_cf.dist = alldists,   pps_cr.dist = alldists )  # Example 1 - PFS endpoint, distribution 2 (weibullPH) allfits_par$pfs[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.9313  0.8080  1.0733  0.0675 #> scale  0.0676  0.0453  0.1009  0.0138 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0729, df = 2 #> AIC = 1028.146  # Example 2 - Parameter values for PPS-CF and PPS-CR endpoints for distribution 3 (llogis) allfits_par$pps_cf[[3]]$result$res #>             est     L95%     U95%        se #> shape  1.625037 1.264658  2.08811 0.2078833 #> scale 12.184292 8.588947 17.28465 2.1737642 allfits_par$pps_cr[[3]]$result$res #>             est     L95%      U95%        se #> shape  1.602773 1.321696  1.943626 0.1576797 #> scale 11.031674 8.769443 13.877487 1.2917274 # Pick out best distribution according to min AIC fitpar.ppd <- find_bestfit(allfits_par$ppd, \"aic\") fitpar.ttp <- find_bestfit(allfits_par$ttp, \"aic\") fitpar.pfs <- find_bestfit(allfits_par$pfs, \"aic\") fitpar.os <- find_bestfit(allfits_par$os, \"aic\") fitpar.pps_cf <- find_bestfit(allfits_par$pps_cf, \"aic\") fitpar.pps_cr <- find_bestfit(allfits_par$pps_cr, \"aic\")  # Inspect the selection for PFS fitpar.pfs #> $fit #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.05596  0.04718  0.06637  0.00487 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.5726, df = 1 #> AIC = 1027.145 #>  #>  #> $results #> # A tibble: 7 × 13 #>      id valid conv  posdef  npts dists     pars loglik   aic   bic    ic rankaic #>   <int> <lgl> <lgl> <lgl>  <dbl> <chr>    <dbl>  <dbl> <dbl> <dbl> <dbl>   <dbl> #> 1     1 TRUE  TRUE  TRUE     204 exp          1  -513. 1027. 1030. 1027.       1 #> 2     2 TRUE  TRUE  TRUE     204 weibull…     2  -512. 1028. 1035. 1028.       3 #> 3     3 TRUE  TRUE  TRUE     204 llogis       2  -513. 1031. 1037. 1031.       6 #> 4     4 TRUE  TRUE  TRUE     204 lnorm        2  -517. 1038. 1044. 1038.       7 #> 5     5 TRUE  TRUE  TRUE     204 gamma        2  -512. 1028. 1035. 1028.       4 #> 6     6 TRUE  TRUE  TRUE     204 gompertz     2  -512. 1027. 1034. 1027.       2 #> 7     7 TRUE  TRUE  TRUE     204 gengamma     3  -512. 1030. 1040. 1030.       5 #> # ℹ 1 more variable: rankbic <dbl>"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"royston-parmar-splines-models","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Royston-Parmar splines models","title":"Example use of psm3mkv","text":"alternative approach parametric modeling use Royston-Parmar splines (Royston Parmar 2002). can follow similar approach, using flexsurv (Jackson 2016) identify best-fitting spline distributions. six endpoints, fit 9 spline models: 1, 2 3 (internal) knots either odds, hazard normal scales. uses fit_ends_mods_spl(). fitted multiple splines endpoint. need retain best-fitting distribution, select basis distribution lowest Akaike Information Criterion (AIC). use find_bestfit() .","code":"# Fit 1-3 knot splines with all 3 scales (odds, hazard, normal) to each endpoint allfits_spl <- fit_ends_mods_spl(bosonc)  # Example - PFS endpoint - 1 knot, odds scale allfits_spl$pfs[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est        L95%       U95%       se        #> gamma0  -2.848058  -3.298634  -2.397482   0.229890 #> gamma1   0.832337   0.449968   1.214706   0.195090 #> gamma2  -0.025453  -0.051358   0.000453   0.013217 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7148, df = 3 #> AIC = 1029.43 allfits_spl$pfs[[2]]$result$aux$scale # Scale #> [1] \"odds\" allfits_spl$pfs[[2]]$result$aux$knots # Knot locations (log time) #>                 50%            #> -2.233592  2.008522  3.882300 # Pick out best distribution according to min AIC fitspl.ppd <- find_bestfit(allfits_spl$ppd, \"aic\") fitspl.ttp <- find_bestfit(allfits_spl$ttp, \"aic\") fitspl.pfs <- find_bestfit(allfits_spl$pfs, \"aic\") fitspl.os <- find_bestfit(allfits_spl$os, \"aic\") fitspl.pps_cf <- find_bestfit(allfits_spl$pps_cf, \"aic\") fitspl.pps_cr <- find_bestfit(allfits_spl$pps_cr, \"aic\")  # Inspect the selection for PFS fitspl.pfs #> $fit #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.62401  -1.84681  -1.40122   0.11367 #> gamma1   0.37082   0.20155   0.54008   0.08636 #> gamma2  -0.02243  -0.03539  -0.00947   0.00661 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.4637, df = 3 #> AIC = 1028.927 #>  #>  #> $results #> # A tibble: 9 × 14 #>      id valid conv  posdef  npts scales nknots  pars loglik   aic   bic    ic #>   <int> <lgl> <lgl> <lgl>  <dbl> <chr>   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> #> 1     1 TRUE  TRUE  TRUE     204 hazard      1     3  -512. 1030. 1040. 1030. #> 2     2 TRUE  TRUE  TRUE     204 odds        1     3  -512. 1029. 1039. 1029. #> 3     3 TRUE  TRUE  TRUE     204 normal      1     3  -511. 1029. 1039. 1029. #> 4     4 TRUE  TRUE  TRUE     204 hazard      2     4  -512. 1032. 1045. 1032. #> 5     5 TRUE  TRUE  TRUE     204 odds        2     4  -511. 1031. 1044. 1031. #> 6     6 TRUE  TRUE  TRUE     204 normal      2     4  -511. 1031. 1044. 1031. #> 7     7 TRUE  TRUE  TRUE     204 hazard      3     5  -510. 1030. 1046. 1030. #> 8     8 TRUE  TRUE  TRUE     204 odds        3     5  -510. 1030. 1047. 1030. #> 9     9 TRUE  TRUE  TRUE     204 normal      3     5  -510. 1030. 1046. 1030. #> # ℹ 2 more variables: rankaic <dbl>, rankbic <dbl>"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"combine-the-best-fits","dir":"Articles","previous_headings":"Fit survival curves to the relevant endpoints","what":"Combine the best fits","title":"Example use of psm3mkv","text":"Finally, select preferred curves endpoint. may may selected minimum AIC may parametric fits spline fits. list deliberately programmed manually - carefully. example use best fits case merely illustrates options available modeler. Let us count many parameters using model.","code":"# Bring together our preferred fits for each endpoint in a list params <- list(   ppd = fitpar.ppd$fit,   ttp = fitpar.ttp$fit,   pfs = fitspl.pfs$fit,   os = fitspl.os$fit,   pps_cf = allfits_par$pps_cf[[2]]$result,   pps_cr = allfits_spl$pps_cr[[2]]$result ) # Pull out number of parameters used for each endpoint count_npar <- map_vec(1:6, ~ params[[.x]]$npars)  # PSM uses PFS (3) and OS (4) endpoints sum(count_npar[c(3, 4)]) #> [1] 6  # STM_CF uses PPD (1), TTP (2) and PPS_CF (5) endpoints sum(count_npar[c(1, 2, 5)]) #> [1] 6  # STM_CR uses PPD (1), TTP (2) and PPS_CR (6) endpoints sum(count_npar[c(1, 2, 6)]) #> [1] 7"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"comparing-likelihood-values-for-the-three-model-structures","dir":"Articles","previous_headings":"","what":"Comparing likelihood values for the three model structures","title":"Example use of psm3mkv","text":"Given selected survival modeling endpoint, can now calculate compare (log-)likelihood three model structures. can also check output ensure number parameters used model structure matches derived earlier. case, model structures fitted 203 204 patients. Among 203 patients models fitted, STM-CR model greatest likelihood (best fitting) also lowest AIC (efficient). (Since nested models, statistical distributions null hypothesis easily formed, readily derive p-value statistical significance difference.)","code":"ll_all <- calc_likes(bosonc, params) ll_all #> $all #> # A tibble: 4 × 12 #>   methname     npar npts_1 npts_2 npts_3 npts_4 npts_tot  ll_1  ll_2  ll_3  ll_4 #>   <chr>       <dbl>  <int>  <int>  <int>  <int>    <int> <dbl> <dbl> <dbl> <dbl> #> 1 psm_simple      7     72     29     35     68      204 -64.8 -152. -151.   NA  #> 2 psm_complex     8     72     29     35     68      204 -64.8 -148. -149. -471. #> 3 stm_cf          6     72     29     35     68      204 -64.7 -147. -148. -474. #> 4 stm_cr          7     72     29     35     68      204 -64.7 -147. -148. -474. #> # ℹ 1 more variable: ll_tot <dbl> #>  #> $valid #> # A tibble: 4 × 12 #>   methname     npar npts_1 npts_2 npts_3 npts_4 npts_tot  ll_1  ll_2  ll_3  ll_4 #>   <chr>       <dbl>  <int>  <int>  <int>  <int>    <int> <dbl> <dbl> <dbl> <dbl> #> 1 psm_simple      7     72     29     35     67      203 -64.8 -152. -151. -469. #> 2 psm_complex     8     72     29     35     67      203 -64.8 -148. -149. -466. #> 3 stm_cf          6     72     29     35     67      203 -64.7 -147. -148. -468. #> 4 stm_cr          7     72     29     35     67      203 -64.7 -147. -148. -468. #> # ℹ 1 more variable: ll_tot <dbl> #>  #> $sum #> # A tibble: 4 × 8 #>   methname     npts  npar    ll   aic   bic rank_aic rank_bic #>   <chr>       <int> <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl> #> 1 psm_simple    203     7 -836. 1685. 1709.        4        4 #> 2 psm_complex   203     8 -828. 1672. 1698.        3        3 #> 3 stm_cf        203     6 -828. 1667. 1687.        2        1 #> 4 stm_cr        203     7 -827. 1667. 1690.        1        2"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"comparing-the-implied-restricted-mean-durations","dir":"Articles","previous_headings":"","what":"Comparing the implied (restricted) mean durations","title":"Example use of psm3mkv","text":"order understand degree structural uncertainty (sensitivity choice model structure), calculate (restricted) mean durations progression-free (PF) progressed disease (PD) states model type. , call calc_allrmds() function dataset statistical distributions wish consider endpoint. function also allows specification patient subset use (inclset, important bootstrapping later) time horizon. units time horizon 52.18 times shorter units output - time horizon can considered units years, whereas output units weeks. two STMs estimate duration PF state slightly longer PSM. PSM also estimates least time PD state alive overall models. STM-CF provides longest estimate time PD state overall. output can bootstrapped generate standard errors. use just 10 boostrap samples (R=10) just illustrate process. practice, want use far 10 samples. Note percentiles information reported indicates small number samples, restricted mean duration PD restricted negative PSM. indicates inconsistency statistical models used case modeling PFS OS, may additional reason STMs may preferred case.","code":"# Call the RMD functions rmd_all <- calc_allrmds(bosonc, dpam = params)  # Then review the mean duration in PF, PD and total alive (OS) rmd_all$results #> # A tibble: 3 × 4 #>      pf    pd    os model  #>   <dbl> <dbl> <dbl> <chr>  #> 1  22.0  5.41  27.4 PSM    #> 2  20.0 10.4   30.4 STM-CF #> 3  20.0 13.3   33.3 STM-CR # Bootstrap to calculate SE over 10 bootstrap samples boot::boot(   data = bosonc,   statistic = calc_allrmds,   R = 10, # Number of samples   cuttime = 0,   Ty = 10,   dpam = params,   boot = TRUE ) #>  #> ORDINARY NONPARAMETRIC BOOTSTRAP #>  #>  #> Call: #> boot::boot(data = bosonc, statistic = calc_allrmds, R = 10, cuttime = 0,  #>     Ty = 10, dpam = params, boot = TRUE) #>  #>  #> Bootstrap Statistics : #>     original     bias    std. error #> t1* 22.02965  1.6639145    3.764406 #> t2* 19.95750  1.0415112    3.079635 #> t3* 19.95750  1.0415112    3.079635 #> t4*  5.41287 -0.4906403    3.728078 #> t5* 10.41262  0.7997145    2.232518 #> t6* 13.32346  1.4157501    3.260064 #> t7* 27.44252  1.1732742    2.421223 #> t8* 30.37012  1.8412257    2.909540 #> t9* 33.28096  2.4572614    3.736715"},{"path":"https://merck.github.io/psm3mkv/articles/example.html","id":"visual-inspection-of-model-fits","dir":"Articles","previous_headings":"","what":"Visual inspection of model fits","title":"Example use of psm3mkv","text":"Creating four graphics model fit straightforward. can compare state membership probabilities PF PD states.  PF curves fully overlap observed period, appear fit well visually observed PF data.  big differences fit models PD membership probability. best visual fit comes PSM. STMs estimate higher probability PD membership later times observed. highest probabilities STM-CF model. Next, can look probabilities alive (.e: membership either PF PD state).  , three models fit fairly well 15 weeks. closest visual fit OS curve PSM. surprising PSM involves fitting OS endpoint directly. Following PD membership graphics, STMs appear -estimate OS longer durations relative observed data. However, recall overall PSM worse fit data according likelihood, AIC BIC. Finally can look probabilities post-progression survival. observed fitted STMs PSM. STM-CR estimate follows directly fitted PPS-CR survival curve. STM-CF estimate derived based average, across patients, patients’ expected PPS-CF survival relative TTP timepoint.","code":"# Generate graphs (can take time) ptdgraphs <- graph_survs(bosonc, params) # State membership probabilities for PF state ptdgraphs$graph$pf + scale_color_npg() #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`). # State membership probabilities for PD state ptdgraphs$graph$pd + scale_color_npg() #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`). # State membership probabilities for OS ptdgraphs$graph$os + scale_color_npg() # Probabilities of PPS ptdgraphs$graph$pps + scale_color_npg() #> Warning: Removed 393 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":[]},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Mortality adjustments","text":"second series vignettes illustrating methods evaluating fit efficiency three state oncology cost-effectiveness model structures, described accompanying journal article (Muston 2024). package heavily dependent flexsurv (Jackson 2016). fitting models, described vignette(\"example\"), estimates Restricted Mean Durations (RMDs) health states can calculated constraining background mortality given life table.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"notation","dir":"Articles","previous_headings":"Introduction","what":"Notation","title":"Mortality adjustments","text":"denote functions survival, hazard cumulative hazard S(t),h(t)S(t), h(t) H(t)H(t). ‘unadjusted’ values relevant endpoints (e.g. PFS) dependent model structure (PSM, STM-CF STM-CR). assume ‘general background mortality’, extrapolations derivations RMD constrained, denoted subscript ‘gen’. Consequently ‘adjusted’ values, denoted superscript ‘adj’.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"background-mortality-survival-and-hazard-functions","dir":"Articles","previous_headings":"Introduction","what":"Background mortality survival and hazard functions","title":"Mortality adjustments","text":"lifetable gives us decreasing lxl_x values points t=0,...,tmaxt=0, ..., t_{max}, ltmax=0l_{t_{max}}=0. Let us define background mortality survival function follows. Sgen(t)=1−R(1−lx0+tlx0) S_{gen}(t) = 1 - R \\left(1 - \\frac{l_{x_0 + t}}{l_{x_0}} \\right) x0x_0 mean age study population baseline, RR Standardized Mortality Ratio, lxl_x appropriate lifetable. can also derive average background mortality hazard tt range [t1,t2)[t_1, t_2). hgen(t)=log[Sgen(t1)]−log[Sgen(t2)]t2−t1 h_{gen}(t) = \\frac{\\log[S_{gen}(t_1)] - \\log[S_{gen}(t_2)]}{t_2 - t_1}","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"what-does-constraining-for-background-mortality-mean","dir":"Articles","previous_headings":"","what":"What does constraining for background mortality mean?","title":"Mortality adjustments","text":"number approaches applied literature HTA submissions, mean several things!","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-1---constraining-only-the-survival-function","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 1 - Constraining only the survival function","title":"Mortality adjustments","text":"approach, background mortality assumed limit survival function follows. direct constraint hazard. Sadj(t)=min[S(t),Sgen(t)] S^{adj}(t) = \\min \\left[ S(t), S_{gen}(t) \\right] simple approach, used least one NICE technology appraisal (National Institute Health Care Excellence 2022): “Patient longevity always lesser values generated disease-specific survival curve (adjustment treatment functional status) survival curve general population according age sex.” However, approach ensure hazard least great hazard background mortality.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-2---constraining-the-hazard-function","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 2 - Constraining the hazard function","title":"Mortality adjustments","text":"rigorous adjustment hazard background mortality acts constraint unadjusted hazard (Sweeting et al. 2023). hadj(t)=max[h(t),hgen(t)] h^{adj}(t) = \\max \\left[ h(t), h_{gen}(t) \\right] ⟹Sadj(t)=exp[−∫0thadj(u)du] \\implies S^{adj}(t) = \\exp \\left[ - \\int_0^t h^{adj}(u) du \\right] either case, must assume original dataset subject background mortality. Although unlikely true, common, pragmatic assumption cost-effectiveness models long background mortality relatively insignificant trial follow-.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"approach-3---modeling-excess-hazard-in-the-original-dataset","dir":"Articles","previous_headings":"What does constraining for background mortality mean?","what":"Approach 3 - Modeling excess hazard in the original dataset","title":"Mortality adjustments","text":"approaches work adjusting extrapolations made models fitted data assumed subject background mortality. - likely - population dataset fact subject background mortality, better model dataset using excess hazard methods rather seek make adjustments extrapolations fact. discussion survival extrapolation incorporating general population mortality provided Sweeting et al. (2023).","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"application-to-3-state-state-transition-models-stms","dir":"Articles","previous_headings":"","what":"Application to 3-state State Transition Models (STMs)","title":"Mortality adjustments","text":"discussed previously, state transition models three states may clock forward (‘STM-CF’) ‘clock reset’ (STM-CR). structures involve modeling transition directly, may performed fitting survival distributions TTP, PPD PPS endpoints. general, wish constrain pre- post-progression mortality (PPD PPS) least great background mortality. $$ h^{adj}_{PPD}(t) = \\max \\left[h_{gen}(t), h_{PPD}(t) \\right] \\\\ h^{adj}_{PPS}(t) = \\max \\left[h_{gen}(t), h_{PPS}(t) \\right] \\\\ $$ Formulas mean time PF OS shown accompanying article respect hazard survival functions TTP, PPD PPS endpoints, PPS function time baseline Clock Forward (CF) time progression Clock Reset (CR) model. Adjusting background mortality requires using adjusted rather unadjusted hazards PPD PPS formulae. straightforward enough PPD endpoint STM-CF STM-CR structures, PPS endpoint STM-CF structure. However matters complex PPS endpoint STM-CF since hazard survival functions two times (time progression time baseline) rather just one (time baseline). package provide integral solutions relying continuous time RMDs, must instead rely discretization. Spreadsheet-based economic models almost always rely discretizing time timesteps rather follow integral formulas described continuous time. long timesteps reasonably short, restricted mean duration results remain reasonably accurate. Derided “kludge”, half-cycle corrections nevertheless recommended (Naimark, Kabboul, Krahn 2013). package provides discretized calculations.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"application-to-partitioned-survival-models-psm","dir":"Articles","previous_headings":"","what":"Application to Partitioned Survival Models (PSM)","title":"Mortality adjustments","text":"RMD PF state time alive integrals time horizon, TT, survival functions endpoints PFS OS. Endpoints PPD PPS explicitly defined. However discussed accompanying manuscript, TTP - therefore PPD PPS endpoints directly follow PFS OS defined - often practice implicitly defined PSM economic model order calculate payoffs depend progression events. Two methods possible: Simple (default): hazard TTP relative PFS proportionate progression events observed follow-period relative total number observed PFS events. Complex: hazard TTP directly modeled fitting survival distributions endpoints. adjustment RMD estimates can proceed STMs, hazards survival functions TTP, PPD PPS reflect PSM structure (PFS OS endpoints first estimated), chosen model progression (simple complex), finally adjustment PPD PPS background mortality.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"set-up","dir":"Articles","previous_headings":"Illustration of calculations","what":"Set-up","title":"Mortality adjustments","text":"First load packages need - suggested imported psm3mkv. haven’t installed psm3mkv yet, please see installation instructions install dependencies. , making use Wickham et al. (2023), Riffe (2015) Müller Wickham (2023).","code":"library(\"dplyr\") #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(\"psm3mkv\") library(\"tibble\")"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"creating-the-life-table","dir":"Articles","previous_headings":"Illustration of calculations","what":"Creating the life table","title":"Mortality adjustments","text":"order apply constraints background mortality, need background mortality data, form lifetable. can take Human Mortality Database using HMDHFDplus package mentioned (thanks Robert Hettle recommendation). lifetable need start assumed age baseline. Lifetables constructed time years. see code run without login Human Mortality Database. Alternatively, just make mortality table. However , mortality data, can apply SMR (RR) derive lifetable time zero required.","code":"# HMD HFD package library(\"HMDHFDplus\")  # Assumed population age at baseline (time=0) baseage <- 51.0  # Mortality data - England & Wales, Female, 2019 mort <- readHMDweb(   CNTRY = \"GBRTENW\",   item = \"fltper_1x1\",   username = \"\",   password = \"\" ) |>   filter(Year == 2019) |>   select(Age, lx, dx) |>   mutate(Timey = ceiling(Age - baseage)) |>   filter(Timey >= 0)  # The table needs to end with lx=0 mort <- add_row(mort, Age = 111, lx = 0, Timey = 60) mort <- tibble(   Timey = 0:30,   lx = 10000 * exp(-0.03 * Timey^1.1),   dx = lx - lead(lx),   qx = dx / lx ) # Assumed Standardized Mortality Ratio SMR <- 2  # Recalculate the lifetable with the SMR applied mort$adjlx <- mort$lx for (i in 2:length(mort$lx)) {   mort$adjlx[i] <- mort$adjlx[i - 1] * (1 - SMR * mort$qx[i - 1]) }  # Ensure lx>=0 mort$adjlx[mort$adjlx < 0] <- 0  # Create and view lifetable ltable <- tibble(lttime = mort$Timey, lx = mort$adjlx) head(ltable) #> # A tibble: 6 × 2 #>   lttime     lx #>    <int>  <dbl> #> 1      0 10000  #> 2      1  9409. #> 3      2  8774. #> 4      3  8151. #> 5      4  7553. #> 6      5  6985."},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"obtaining-and-fitting-distributions-to-patient-level-data","dir":"Articles","previous_headings":"Illustration of calculations","what":"Obtaining and fitting distributions to patient-level data","title":"Mortality adjustments","text":"Next get patient-level data fit PSM STMs. far, closely following vignette(\"example\"). Time assumed recorded patient-level data weeks, approximately 52.18 weeks per year.","code":"# Get some data bosonc <- create_dummydata(\"flexbosms\")  # We'll make the durations a lot longer # so that they will be definitely constrained by the lifetable bosonc <- bosonc |>   mutate(     pfs.durn = 20 * pfs.durn,     os.durn = 20 * os.durn,     ttp.durn = 20 * ttp.durn   )  # Fit parametric models to each endpoint allfits <- fit_ends_mods_par(bosonc)  # Bring together preferred fits for each endpoint params <- list(   ppd = find_bestfit(allfits$ppd, \"aic\")$fit,   ttp = find_bestfit(allfits$ttp, \"aic\")$fit,   pfs = find_bestfit(allfits$pfs, \"aic\")$fit,   os = find_bestfit(allfits$os, \"aic\")$fit,   pps_cf = find_bestfit(allfits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(allfits$pps_cr, \"aic\")$fit )"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"making-the-projections","dir":"Articles","previous_headings":"Illustration of calculations","what":"Making the projections","title":"Mortality adjustments","text":"skipping internal external validation purposes vignette, jump instead straight making survival projections. assume 10 year time horizon. First derive projection using integral formulae, without lifetable constraints. Next derive projection using discretization approximation, still without lifetable constraints. Discretization proven fairly accurate. STM-CR estimate mean time alive reduced just 0.1 weeks example, 393.9 393.8 weeks. Finally, use discretization approximation apply lifetable constraints. now difference STM-CR compared STM-CF PSM structures. structures estimate fairly similar RMD estimates alive (range: 337.7 341.6 weeks). estimate mean time alive STM-CR structure reduced 52.3 weeks 393.9 341.6 weeks. proportion time PF rather PD state varies somewhat (PSM: 69%, STM-CF: 68.1%, STM-CR: 67.3%). Given hazard mortality typically lower rather progression, pre-progression mortality likely affected mortality constraint post-progression mortality. STM-CR model post-progression survival depends time progression therefore rather different STM-CF PSM structures, model mortality based time baseline. can check whether using ‘complex’ type PSM structure rather default ‘simple’ affects RMD estimates PSM structure. structures estimate fairly similar RMD estimates alive (range: 334.7 341.6 weeks). proportion time PF rather PD state varied little model structure (PSM: 69%, STM-CF: 68.1%, STM-CR: 67.3%).","code":"# Set time horizon thoz <- 10  # Run the calculations proj1 <- calc_allrmds(bosonc, dpam = params, Ty = thoz)  # Present the results res1 <- proj1$results |> mutate(method = \"int\", lxadj = \"no\", psmmeth = \"simple\") res1 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1)) ) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     274.4     118.3     392.7 PSM    int    no    simple  #> 2     270.2     119.7     389.9 STM-CF int    no    simple  #> 3     270.2     123.8     393.9 STM-CR int    no    simple # Run the calculation proj2 <- calc_allrmds(bosonc, dpam = params, Ty = thoz, rmdmethod = \"disc\")  # Present the results res2 <- proj2$results |>   mutate(method = \"disc\", lxadj = \"no\", psmmeth = \"simple\") res2 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1)) ) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     274.3     118.3     392.6 PSM    disc   no    simple  #> 2     270.1     119.7     389.8 STM-CF disc   no    simple  #> 3     270.1     123.7     393.8 STM-CR disc   no    simple # Run the calculations proj3 <- calc_allrmds(bosonc, dpam = params, Ty = thoz, rmdmethod = \"disc\", lifetable = ltable)  # Present the results res3 <- proj3$results |>   mutate(method = \"disc\", lxadj = \"yes\", psmmeth = \"simple\") res3 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1)) ) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     235.4     105.5     340.9 PSM    disc   yes   simple  #> 2     230.1     107.6     337.7 STM-CF disc   yes   simple  #> 3     230.1     111.6     341.6 STM-CR disc   yes   simple  # Proportion of time alive spent in PF proppf3 <- res3$pf / res3$os # Run the calculations proj4 <- calc_allrmds(bosonc, dpam = params, Ty = thoz, psmtype = \"complex\", rmdmethod = \"disc\", lifetable = ltable)  # Present the results res4 <- proj4$results |>   mutate(method = \"disc\", lxadj = \"yes\", psmmeth = \"complex\") res4 |> mutate(   across(c(pf, pd, os), ~ num(.x, digits = 1)) ) #> # A tibble: 3 × 7 #>          pf        pd        os model  method lxadj psmmeth #>   <num:.1!> <num:.1!> <num:.1!> <chr>  <chr>  <chr> <chr>   #> 1     231.0     103.7     334.7 PSM    disc   yes   complex #> 2     230.1     107.6     337.7 STM-CF disc   yes   complex #> 3     230.1     111.6     341.6 STM-CR disc   yes   complex  # Proportion of time alive spent in PF proppf4 <- res4$pf / res4$os"},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"comparing-the-results","dir":"Articles","previous_headings":"Illustration of calculations","what":"Comparing the results","title":"Mortality adjustments","text":"summary STM-CF estimates mean time PF state mean time alive given table . fictional case, application lifetable constraint fairly sizeable effects results - although design demonstration. summary STM-CR estimates mean time PF state mean time alive given table . application lifetable constraint similar fairly sizeable effects results also. summary PSM estimates mean time PF state mean time alive given table . change RMDs ‘complex’ PSM structure compared ‘simple’ PSM structure -4.3, -1.9 -6.2 weeks respectively time PF state, PD state time alive.","code":""},{"path":"https://merck.github.io/psm3mkv/articles/mortality-adjustments.html","id":"possible-extensions","dir":"Articles","previous_headings":"Illustration of calculations","what":"Possible extensions","title":"Mortality adjustments","text":"applied , package also allows application discounting discrate optional call calc_allrnds(). work also easily extended calculating RMDs Life Years Quality Adjusted (QALYs).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dominic Muston. Author, maintainer. Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder, funder.","code":""},{"path":"https://merck.github.io/psm3mkv/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Muston D (2024). “Informing Structural Assumptions Three State Oncology Cost-Effectiveness Models Model Efficiency Fit.” Applied Health Economics Health Policy. doi:10.1007/s40258-024-00884-2.","code":"@Article{,   title = {Informing Structural Assumptions for Three State Oncology Cost-Effectiveness Models through Model Efficiency and Fit},   author = {Dominic Muston},   journal = {Applied Health Economics and Health Policy},   year = {2024},   doi = {10.1007/s40258-024-00884-2}, }"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"psm3mkv-a-package-to-evaluate-the-fit-and-efficiency-of-three-state-oncology-cost-effectiveness-model-structures-","dir":"","previous_headings":"","what":"Evaluate Partitioned Survival and State Transition Models","title":"Evaluate Partitioned Survival and State Transition Models","text":"goal psm3mkv evaluate efficiency fit certain three state model structures data typical oncology clinical trial, described accompanying article (Muston 2024). package evaluates following structures: Partitioned Survival Model/analysis (PSM), Clock-forward State Transition Model (STM-CF), Clock-reset State Transition Model (STM-CR). state transition models differ transition progressive disease death function time baseline STM-CF time progression STM-CR (Jackson 2016; Woods et al. 2020). package requires patient-level dataset time progression (TTP), progression-free survival (PFS) overall survival (OS). Given , package enables: Fitting range models endpoints relevant model type: One piece parametric (distributions according flexsurv). Royston-Parmar splines (1-3 internal knots, hazard/odds/normal scales, per flexsurv) (Royston Parmar 2002). Two piece parametric (given time cutoff). Selecting “best fit” survival models endpoint (using Akaike Information Criterion, Bayesian Information Criterion user preference). Deriving presenting likelihoods 3 structures evaluate fit. Presenting total number parameters used structure, additionally evaluate efficiency. Deriving presenting restricted mean durations health state 3 model structures (given time horizon), evaluate plausibility structural sensitivity. Additional functionality: Constraining estimates ensure survival greater survival background lifetable. Applying discounting obtained discounted restricted means. Bootstrap standard errors can derived. Graphically illustrate observed fitted membership probabilities, allow visual inspection fit 3 model structures. two piece modeling used, modelers advised take care interpretation validity case different cutoff points selected different endpoints. Additionally, parametric modeling STM structures, model survival progressive disease state (post progression survival, PPS) may function additional arbitrary explanatory variable. intended enable exploration TTP (transformation) predictor PPS.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Evaluate Partitioned Survival and State Transition Models","text":"accompanying vignette(\"example\") illustrates package can used one-piece parametric spline modeling. second vignette, vignette(\"background-mortality\") illustrates , fitting models, estimates restricted mean durations health states can calculated constraining background mortality given life table. Survival assumed greater background lifetable.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Evaluate Partitioned Survival and State Transition Models","text":"package requires version R >= 4.1.0 due use native pipe. Please ensure R updated first.","code":""},{"path":"https://merck.github.io/psm3mkv/index.html","id":"latest-stable-release","dir":"","previous_headings":"Installation","what":"Latest stable release","title":"Evaluate Partitioned Survival and State Transition Models","text":"Install latest stable release CRAN:","code":"install.packages(\"psm3mkv\")"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"development-version","dir":"","previous_headings":"Installation","what":"Development version","title":"Evaluate Partitioned Survival and State Transition Models","text":"Install latest development version GitHub (may stable): Note pak::pak() build vignettes default installing package GitHub, ideal vignettes can take long time generate. can conveniently view package documentation website.","code":"# install.packages(\"pak\") pak::pak(\"Merck/psm3mkv@main\")"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"additional-dependencies","dir":"","previous_headings":"Installation","what":"Additional dependencies","title":"Evaluate Partitioned Survival and State Transition Models","text":"Running vignettes requires additional dependencies, either imported suggested psm3mkv. Thus can ensure installed specifying dependencies = TRUE.","code":"pak::pak(\"Merck/psm3mkv@*release\", dependencies = TRUE)"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Evaluate Partitioned Survival and State Transition Models","text":"use software, please cite . Muston, D. 2024. “Informing Structural Assumptions Three State Oncology Cost-Effectiveness Models Model Efficiency Fit.” Applied Health Economics Health Policy. DOI: 10.1007/s40258-024-00884-2 BibTeX entry LaTeX users ","code":"@article{muston2024informing,   author  = {Dominic Muston},   title   = {Informing structural assumptions for three state oncology cost-effectiveness models through model efficiency and fit},   journal = {Applied Health Economics and Health Policy},   year    = {2024},   doi     = {10.1007/s40258-024-00884-2} }"},{"path":"https://merck.github.io/psm3mkv/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Evaluate Partitioned Survival and State Transition Models","text":"Jackson, Christopher. 2016. “flexsurv: Platform Parametric Survival Modeling R.” Journal Statistical Software 70 (8): 1–33. Woods, Beth S, Eleftherios Sideris, Stephen Palmer, Nick Latimer, Marta Soares. 2020. “Partitioned Survival State Transition Models Healthcare Decision Making Oncology: Now?” Value Health 23 (12): 1613–1621. Royston, Patrick, Mahesh KB Parmar. 2002. “Flexible Parametric Proportional-Hazards Proportional-Odds Models Censored Survival Data, Application Prognostic Modelling Estimation Treatment Effects.” Statistics Medicine 21 (15): 2175–2197.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"Calculate restricted mean durations health state (progression free progressed disease) three models (partitioned survival, clock forward state transition model, clock reset state transition model).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"","code":"calc_allrmds(   ptdata,   inclset = 0,   dpam,   psmtype = \"simple\",   cuttime = 0,   Ty = 10,   lifetable = NA,   discrate = 0,   rmdmethod = \"int\",   timestep = 1,   boot = FALSE )"},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). inclset Vector indicate patients include analysis dpam List statistical fits endpoint required PSM, STM-CF STM-CR models. psmtype Either \"simple\" \"complex\" PSM formulation cuttime Time cutoff - nonzero two-piece models. Ty Time duration calculate. Assumes input years, patient-level data recorded weeks. lifetable Optional, life table. Columns must include lttime (time years, 52.18 times shorter time index elsewhere, starting zero) lx discrate Discount rate (% per year) rmdmethod can \"int\" (default full integral calculations) \"disc\" approximate discretized calculations timestep required method==\"int\", default 1 boot logical flag indicate whether abbreviated output required (default = FALSE), example bootstrapping","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"List detailed numeric results cutadj indicates survival function area curves PFS OS cutpoint results provides results restricted means calculations, model state.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_allrmds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted mean durations for each health state and all three models — calc_allrmds","text":"","code":"# \\donttest{ # Create dataset and fit survival models (splines) bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) # RMD using default \"int\" method, no lifetable constraint calc_allrmds(bosonc, dpam=params) #> $cutadj #> $cutadj$pfarea #> [1] 0 #>  #> $cutadj$pfsurv #> [1] 1 #>  #> $cutadj$osarea #> [1] 0 #>  #> $cutadj$ossurv #> [1] 1 #>  #>  #> $results #> # A tibble: 3 × 4 #>      pf    pd    os model  #>   <dbl> <dbl> <dbl> <chr>  #> 1  17.9  9.82  27.7 PSM    #> 2  20.0 10.7   30.7 STM-CF #> 3  20.0 10.1   30.0 STM-CR #>  # RMD using discretized (\"disc\") method, no lifetable constraint calc_allrmds(bosonc, dpam=params, rmdmethod=\"disc\", timestep=1, boot=TRUE) #> [1] 17.87470 19.96263 19.96263 11.98304 10.73811 10.07684 29.85774 30.70075 #> [9] 30.03948 # }"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"Derive hazards death pre- post-progression either simple complex PSM formulations.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"","code":"calc_haz_psm(timevar, ptdata, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"timevar Vector times calculate hazards ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"List pre, pre-progression hazard, post, post-progression hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_haz_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive pre and post-progression hazards of death under PSM — calc_haz_psm","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit   ) calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype=\"simple\") #> $adj #> $adj$ttp #>  [1] 0.00000000 0.04742078 0.04722152 0.04707233 0.04682576 0.04650723 #>  [7] 0.04614387 0.04575442 0.04533051 0.04479742 0.04418546 #>  #> $adj$ppd #>  [1] 0.000000000 0.009903692 0.013295380 0.013253374 0.013183952 0.013094269 #>  [7] 0.012991963 0.012882314 0.012762960 0.012612865 0.012440568 #>  #> $adj$pfs #>  [1] 0.00000000 0.05732447 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $adj$os #>  [1] 0.000000000 0.009300758 0.012253823 0.014430772 0.016195615 0.017678549 #>  [7] 0.018943502 0.020027650 0.020955175 0.021743175 0.022404577 #>  #> $adj$pps #>  [1] 0.000000000 0.000000000 0.005094092 0.024838109 0.034454269 0.040318847 #>  [7] 0.044430336 0.047603965 0.050244788 0.052614795 0.054815057 #>  #>  #> $unadj #> $unadj$ttp #>  [1] 0.00000000 0.04742078 0.04722152 0.04707233 0.04682576 0.04650723 #>  [7] 0.04614387 0.04575442 0.04533051 0.04479742 0.04418546 #>  #> $unadj$ppd #>  [1] 0.00000000 0.01335148 0.01329538 0.01325337 0.01318395 0.01309427 #>  [7] 0.01299196 0.01288231 0.01276296 0.01261286 0.01244057 #>  #> $unadj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $unadj$os #>  [1] 0.000000000 0.009363175 0.012472587 0.014891286 0.016981265 0.018871673 #>  [7] 0.020625521 0.022278934 0.023854812 0.025368713 0.026831756 #>  #> $unadj$pps #>  [1]         NaN 0.000000000 0.005094092 0.024838109 0.034454269 0.040318847 #>  [7] 0.044430336 0.047603965 0.050244788 0.052614795 0.054815057 #>  #>  calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype=\"complex\") #> $adj #> $adj$ttp #>  [1] 0.00000000 0.05758869 0.05337416 0.05075486 0.04878425 0.04717919 #>  [7] 0.04581438 0.04459666 0.04337732 0.04216807 0.04098853 #>  #> $adj$ppd #>  [1] 0.000000000 0.003183577 0.007142746 0.009570846 0.011225462 0.012422312 #>  [7] 0.013321453 0.014040074 0.014716157 0.015242215 0.015637501 #>  #> $adj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $adj$os #>  [1] 0.000000000 0.009300758 0.012253823 0.014430772 0.016195615 0.017678549 #>  [7] 0.018943502 0.020027650 0.020955175 0.021743175 0.022404577 #>  #> $adj$pps #>  [1] 0.00000000 0.11640992 0.06026855 0.04720160 0.04346609 0.04281332 #>  [7] 0.04340284 0.04448366 0.04559770 0.04699859 0.04859870 #>  #>  #> $unadj #> $unadj$ttp #>  [1] 0.00000000 0.05758869 0.05337416 0.05075486 0.04878425 0.04717919 #>  [7] 0.04581438 0.04459666 0.04337732 0.04216807 0.04098853 #>  #> $unadj$ppd #>  [1] 0.000000000 0.003183577 0.007142746 0.009570846 0.011225462 0.012422312 #>  [7] 0.013321453 0.014040074 0.014716157 0.015242215 0.015637501 #>  #> $unadj$pfs #>  [1] 0.00000000 0.06077226 0.06051690 0.06032570 0.06000971 0.05960150 #>  [7] 0.05913583 0.05863674 0.05809348 0.05741028 0.05662603 #>  #> $unadj$os #>  [1] 0.000000000 0.009363175 0.012472587 0.014891286 0.016981265 0.018871673 #>  [7] 0.020625521 0.022278934 0.023854812 0.025368713 0.026831756 #>  #> $unadj$pps #>  [1]        NaN 0.11640992 0.06026855 0.04720160 0.04346609 0.04281332 #>  [7] 0.04340284 0.04448366 0.04559770 0.04699859 0.04859870 #>  #>  # }"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate likelihoods for three three-state model structures — calc_likes","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"Calculate likelihood values summary output following three state models structures: partitioned survival, clock forward state transition, clock reset state transition. function requires appropriately formatted patient-level data, set fitted survival regressions, time cut-(two-piece modeling used).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"","code":"calc_likes(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"list three tibbles: tibble results patients: methname: model structure method. npar: number parameters used method. npts_1 npts_4 number patients experiencing outcomes 1-4 respectively (see ), npts_tot total. ll_1 ll_4 log-likelihood values patients experiencing outcomes 1-4 respectively (see ), ll_tot total. valid tibble design patients valid likelihoods 4 methods sum tibble respect patients valid likelihoods 4 methods providing: npts: number patients contributing results method. npar: number parameters used method. ll: total log-likelihood AIC: Akaike Information Criterion value model BIC: Bayesian Information Criterion value model four outcomes follows: (1) refers patients remain alive progression-free follow-; (2) refers patients die without prior progression follow-; (3) refers patients progress remain alive remaining follow-, (4) refers patients progress die within follow-.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_likes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate likelihoods for three three-state model structures — calc_likes","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit   ) calc_likes(bosonc, dpam=params) #> $all #> # A tibble: 4 × 12 #>   methname     npar npts_1 npts_2 npts_3 npts_4 npts_tot  ll_1  ll_2  ll_3  ll_4 #>   <chr>       <dbl>  <int>  <int>  <int>  <int>    <int> <dbl> <dbl> <dbl> <dbl> #> 1 psm_simple      7     72     29     35     68      204 -64.8 -152. -151.   NA  #> 2 psm_complex     9     72     29     35     68      204 -64.8 -147. -150. -473. #> 3 stm_cf          9     72     29     35     68      204 -65.2 -147. -148. -473. #> 4 stm_cr         10     72     29     35     68      204 -65.2 -147. -148. -470. #> # ℹ 1 more variable: ll_tot <dbl> #>  #> $valid #> # A tibble: 4 × 12 #>   methname     npar npts_1 npts_2 npts_3 npts_4 npts_tot  ll_1  ll_2  ll_3  ll_4 #>   <chr>       <dbl>  <int>  <int>  <int>  <int>    <int> <dbl> <dbl> <dbl> <dbl> #> 1 psm_simple      7     72     29     35     67      203 -64.8 -152. -151. -469. #> 2 psm_complex     9     72     29     35     67      203 -64.8 -147. -150. -468. #> 3 stm_cf          9     72     29     35     67      203 -65.2 -147. -148. -468. #> 4 stm_cr         10     72     29     35     67      203 -65.2 -147. -148. -464. #> # ℹ 1 more variable: ll_tot <dbl> #>  #> $sum #> # A tibble: 4 × 8 #>   methname     npts  npar    ll   aic   bic rank_aic rank_bic #>   <chr>       <int> <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl> #> 1 psm_simple    203     7 -836. 1685. 1709.        4        4 #> 2 psm_complex   203     9 -830. 1679. 1708.        3        3 #> 3 stm_cf        203     9 -828. 1673. 1703.        2        2 #> 4 stm_cr        203    10 -824. 1668. 1701.        1        1 #>  # }"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate restricted mean durations — calc_rmd","title":"Calculate restricted mean durations — calc_rmd","text":"Calculates restricted mean duration, given form parametric distribution Royston-Parmar splines","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate restricted mean durations — calc_rmd","text":"","code":"calc_rmd(Tw, type = NA, spec = NA, survobj = NULL)"},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate restricted mean durations — calc_rmd","text":"Tw time horizon (weeks) mean calculated. type either \"par\" regular parametric form (exponential, weibull etc) \"spl\" Royston-Parmar splines. spec list comprising: type==\"par\": dist statistical distribution (named per flexsurv::flexsurvreg) pars vector parameters distribution. Exponential distribution (exp) requires rate parameter. Weibull distribution (weibullPH weibull formulations) requires shape scale parameters. Log-logistic distribution (llogis) requires shape scale parameters. Log-normal distribution (lnorm) requires meanlog sdlog parameters. Gamma Gompertz distributions (gamma gompertz) require shape rate parameters. Generalized Gamma requires mu, sigma Q parameters using standard parameterization (gengamma) shape, scale k parameters using original parameterization (gengamma.orig). type==\"spl\": gamma - Vector parameters describing baseline spline function, described flexsurv::flexsurvspline. may supplied vector number elements equal length knots, case parameters common times. Alternatively matrix may supplied, rows corresponding different times, columns corresponding knots. knots - Vector locations knots axis log time, supplied increasing order. Unlike flexsurv::flexsurvspline, include two boundary knots. scale - Either \"hazard\", \"odds\", \"normal\", described flexsurv::flexsurvspline. default knots addition boundaries, model reduces Weibull, log-logistic log-normal respectively. scale must common times. survobj survival fit object flexsurv::flexsurvspline flexsurv::flexsurvreg","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate restricted mean durations — calc_rmd","text":"restricted mean duration, numeric value.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_rmd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate restricted mean durations — calc_rmd","text":"","code":"calc_rmd(Tw=200,     type=\"spl\",     spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale=\"normal\")     ) #> [1] 199.9296 calc_rmd(Tw=250,     type=\"par\",     spec=list(dist=\"lnorm\", pars=c(3,1))     ) #> [1] 32.45453"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive PPS survival function under a PSM — calc_surv_psmpps","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"Derive post-progression survival (PPS) function simple complex PSM formulation.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"","code":"calc_surv_psmpps(totime, fromtime = 0, ptdata, dpam, psmtype = \"simple\")"},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"totime Vector times survival function calculated fromtime Vector times survival function calculated ptdata Patient-level dataset dpam List fitted survival models endpoint psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"Vector PPS survival function values","code":""},{"path":"https://merck.github.io/psm3mkv/reference/calc_surv_psmpps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive PPS survival function under a PSM — calc_surv_psmpps","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit   ) calc_surv_psmpps(totime=1:10,   fromtime=rep(1,10),   ptdata=bosonc,   dpam=params,   psmtype=\"simple\") #>  [1] 1.0000000 0.9995962 0.9833657 0.9541989 0.9190001 0.8807816 0.8411186 #>  [8] 0.8009357 0.7607707 0.7209705 # }"},{"path":"https://merck.github.io/psm3mkv/reference/check_consistent_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","title":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","text":"Check consistency PFS definition Check PFS defined consistently TTP OS dataset. convenience function compares pfs.durn lower ttp.durn os.durn, checks event field pfs.flag consistent ttp.flag os.flag (1 either ttp.flag os.flag one).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_consistent_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","text":"","code":"check_consistent_pfs(ds)"},{"path":"https://merck.github.io/psm3mkv/reference/check_consistent_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","text":"ds Tibble complete patient-level dataset ttp.durn, pfs.durn, os.durn durations TTP (time progression), PFS (progression-free survival), OS (overall survival). ttp.flag, pfs.flag, os.flag, pps.flag event flag indicators TTP, PFS, OS respectively (1=event, 0=censoring).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_consistent_pfs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","text":"List containing: durn: Logical vector comparing expected actual PFS durations flag: Logical vector comparing expected actual PFS event flags : Single logical value TRUE durations flags match expected, FALSE otherwise","code":""},{"path":"https://merck.github.io/psm3mkv/reference/check_consistent_pfs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check consistency of PFS definition Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares pfs.durn with the lower of ttp.durn and os.durn, and checks that the event field pfs.flag is consistent with ttp.flag and os.flag (is 1 when either ttp.flag or os.flag is one). — check_consistent_pfs","text":"","code":"ponc <- create_dummydata(\"pharmaonc\") check_consistent_pfs(ponc) #> $durn #>   [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  #> $flag #>   [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  #> $all #> [1] TRUE #>"},{"path":"https://merck.github.io/psm3mkv/reference/compare_psm_likes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare likelihoods of PSMs — compare_psm_likes","title":"Compare likelihoods of PSMs — compare_psm_likes","text":"Compare total log-likelihood values patient-level dataset fitting PSM-simple PSM-complex models combination endpoint distributions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/compare_psm_likes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare likelihoods of PSMs — compare_psm_likes","text":"","code":"compare_psm_likes(ptdata, fitslist, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/compare_psm_likes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare likelihoods of PSMs — compare_psm_likes","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). fitslist List distribution fits relevant endpoints, calling fit_ends_mods_par() fit_ends_mods_spl() cuttime Time cutoff - nonzero two-piece models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/compare_psm_likes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare likelihoods of PSMs — compare_psm_likes","text":"List containing results: Dataset calculation results model bests: Tibble indicating best fitting model individually jointly, endpoint, according AIC BIC","code":""},{"path":"https://merck.github.io/psm3mkv/reference/compare_psm_likes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare likelihoods of PSMs — compare_psm_likes","text":"","code":"# Fit parametric distributions to a dataset bosonc <- create_dummydata(\"flexbosms\") parfits <- fit_ends_mods_par(bosonc) # \\donttest{ splfits <- fit_ends_mods_spl(bosonc) # Present comparison of likelihood calculations compare_psm_likes(bosonc, parfits) #> Calculating PSM simple #> Calculating PSM complex #> Wrapping up #> $results #> # A tibble: 252 × 13 #>       id ttp_meth pfs_dist  os_dist      ll  npar  npts   aic   bic rank_aic #>    <int> <chr>    <chr>     <chr>     <dbl> <dbl> <int> <dbl> <dbl>    <dbl> #>  1     1 simple   exp       exp       -859.     3   204 1725. 1735.      139 #>  2     2 simple   exp       weibullPH -834.     4   203 1676. 1689.       38 #>  3     3 simple   exp       llogis    -839.     4   203 1687. 1700.       93 #>  4     4 simple   exp       lnorm     -839.     4   203 1686. 1699.       91 #>  5     5 simple   exp       gamma     -835.     4   203 1677. 1690.       42 #>  6     6 simple   exp       gompertz  -830.     4   203 1668. 1682.       24 #>  7     7 simple   weibullPH exp       -851.     4   204 1711. 1724.      126 #>  8     8 simple   weibullPH weibullPH -835.     5   203 1680. 1696.       53 #>  9     9 simple   weibullPH llogis    -841.     5   203 1692. 1709.      108 #> 10    10 simple   weibullPH lnorm     -839.     5   203 1687. 1704.       95 #> # ℹ 242 more rows #> # ℹ 3 more variables: rank_bic <dbl>, best_aic <dbl>, best_bic <dbl> #>  #> $bests #> # A tibble: 4 × 5 #>   ttp_meth pfs_dist os_dist   meth  ic    #>   <chr>    <chr>    <chr>     <chr> <chr> #> 1 gompertz exp      weibullPH ind   aic   #> 2 gompertz exp      weibullPH ind   bic   #> 3 gompertz lnorm    gamma     joint aic   #> 4 gompertz lnorm    gamma     joint bic   #>  compare_psm_likes(bosonc, splfits) #> Calculating PSM simple #> Calculating PSM complex #> Wrapping up #> $results #> # A tibble: 810 × 16 #>       id ttp_meth ttp_knots pfs_scales pfs_knots os_scales os_knots    ll  npar #>    <int> <chr>        <dbl> <chr>          <int> <chr>        <int> <dbl> <dbl> #>  1     1 simple           0 hazard             3 hazard           3 -835.     7 #>  2     2 simple           0 hazard             3 odds             3 -840.     7 #>  3     3 simple           0 hazard             3 normal           3 -838.     7 #>  4     4 simple           0 hazard             3 hazard           4 -833.     8 #>  5     5 simple           0 hazard             3 odds             4 -833.     8 #>  6     6 simple           0 hazard             3 normal           4 -832.     8 #>  7     7 simple           0 hazard             3 hazard           5 -833.     9 #>  8     8 simple           0 hazard             3 odds             5 -832.     9 #>  9     9 simple           0 hazard             3 normal           5 -832.     9 #> 10    10 simple           0 odds               3 hazard           3 -825.     7 #> # ℹ 800 more rows #> # ℹ 7 more variables: npts <int>, aic <dbl>, bic <dbl>, rank_aic <dbl>, #> #   rank_bic <dbl>, best_aic <dbl>, best_bic <dbl> #>  #> $bests #> # A tibble: 4 × 8 #>   ttp_meth ttp_knots pfs_scales pfs_knots os_scales os_knots meth  ic    #>   <chr>        <dbl> <chr>          <int> <chr>        <int> <chr> <chr> #> 1 normal           3 normal             3 hazard           3 ind   aic   #> 2 normal           3 normal             3 hazard           3 ind   bic   #> 3 odds             3 normal             4 hazard           4 joint aic   #> 4 simple           0 odds               3 normal           4 joint bic   #>  # }"},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"Constrain survival probabilities according hazards lifetable Recalculated constrained survival probabilities (week) lower original unadjusted survival probability survival implied given lifetable (assumed indexed years).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"","code":"constrain_survprob(   survprob1,   survprob2 = NA,   lifetable = NA,   timevec = 0:(length(survprob1) - 1) )"},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"survprob1 (Unconstrained) survival probability value vector survprob2 Optional survival probability value vector constrain (default = NA) lifetable Lifetable (default = NA) timevec Vector times corresponding survival probabilities ","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"Vector constrained survival probabilities","code":""},{"path":"https://merck.github.io/psm3mkv/reference/constrain_survprob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrain survival probabilities according to hazards in a lifetable Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years). — constrain_survprob","text":"","code":"ltable <- tibble::tibble(lttime=0:20, lx=c(1,0.08,0.05,0.03,0.01,rep(0,16))) survprob <- c(1,0.5,0.4,0.2,0) constrain_survprob(survprob, lifetable=ltable) #> [1] 1.0 0.5 0.4 0.2 0.0 timevec <- 100*(0:4) constrain_survprob(survprob, lifetable=ltable, timevec=timevec) #> [1] 1.00000000 0.05200139 0.01201389 0.00000000 0.00000000 survprob2 <- c(1,0.45,0.35,0.15,0) constrain_survprob(survprob, survprob2) #> [1] 1.00 0.45 0.35 0.15 0.00"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dummy dataset for illustration — create_dummydata","title":"Create dummy dataset for illustration — create_dummydata","text":"Create dummy dataset illustrate psm3mkv","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dummy dataset for illustration — create_dummydata","text":"","code":"create_dummydata(dsname)"},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create dummy dataset for illustration — create_dummydata","text":"dsname Dataset name, follows: flexbosms provides dataset based flexsurv::bosms3(). contains fields necessary psm3mkv. Durations converted months original dataset weeks. pharmaonc provides dataset based pharmaverseadam::adsl pharmaverseadam::adrs_onco demonstrate package can used ADaM ADTTE datasets. survcan provides dataset based survival::cancer(). contains necessary ID overall survival fields . Durations converted days original dataset weeks. additionally need supply PFS TTP data (fields pfs.durn, pfs.flag, ttp.durn ttp.flag) use psm3mkv.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create dummy dataset for illustration — create_dummydata","text":"Tibble dataset, use psm3mkv functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_dummydata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create dummy dataset for illustration — create_dummydata","text":"","code":"create_dummydata(\"survcan\") |> head() #>   ptid   os.durn os.flag #> 1    1  43.71429       1 #> 2    2  65.00000       1 #> 3    3 144.28571       0 #> 4    4  30.00000       1 #> 5    5 126.14286       1 #> 6    6 146.00000       0 create_dummydata(\"flexbosms\") |> head() #> # A tibble: 6 × 7 #>    ptid pfs.durn pfs.flag os.durn os.flag ttp.durn ttp.flag #>   <int>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl> #> 1     1   18.7          1   42.9        1   18.7          1 #> 2     2   12.0          1   23.3        1   12.0          1 #> 3     3    0.452        1    8.81       1    0.452        1 #> 4     4    9.07         1   52.7        1    9.07         1 #> 5     5   47.7          0   47.7        0   47.7          0 #> 6     6    3.26         1   13.1        1    3.26         1 create_dummydata(\"pharmaonc\") |> head() #> # A tibble: 6 × 7 #>   ptid        ttp.durn ttp.flag pfs.durn pfs.flag os.durn os.flag #>   <chr>          <dbl>    <dbl>    <dbl>    <dbl>   <dbl>   <dbl> #> 1 01-701-1015    25.9         0    25.9         0   25.9        0 #> 2 01-701-1023     4           0     4           0    4          0 #> 3 01-701-1028     6           1     6           1   25.6        0 #> 4 01-701-1033     3.86        0     3.86        0    3.86       0 #> 5 01-701-1034    26           0    26           0   26          0 #> 6 01-701-1047     7.71        0     7.71        0    7.71       0"},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"Create additional time--event endpoints, adjusting cutpoint","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"","code":"create_extrafields(ds, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"ds Patient-level dataset cuttime Time cutpoint","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"Tibble complete patient-level dataset, adjusted cutpoint ttp.durn, pfs.durn, ppd.durn os.durn durations TTP (time progression), PFS (progression-free survival), PPD (pre-progression death) OS (overall survival) respectively beyond cutpoint. pps.durn duration survival beyond progression, irrespective cutpoint. pps.odurn difference ttp.durn os.durn (may different pps.durn). ttp.flag, pfs.flag, ppd.flag, os.flag, pps.flag event flag indicators TTP, PFS, PPD, OS PPS respectively (1=event, 0=censoring).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/create_extrafields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the additional time-to-event endpoints, adjusting for cutpoint — create_extrafields","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") create_extrafields(bosonc, cuttime=10) #> # A tibble: 204 × 16 #>     ptid pfs.odurn pfs.flag os.odurn os.flag ttp.odurn ttp.flag ttp.durn #>    <int>     <dbl>    <dbl>    <dbl>   <dbl>     <dbl>    <dbl>    <dbl> #>  1     1    18.7          1    42.9        1    18.7          1    8.67  #>  2     2    12.0          1    23.3        1    12.0          1    2.01  #>  3     3     0.452        1     8.81       1     0.452        1    0     #>  4     4     9.07         1    52.7        1     9.07         1    0     #>  5     5    47.7          0    47.7        0    47.7          0   37.7   #>  6     6     3.26         1    13.1        1     3.26         1    0     #>  7     7     0.738        1     2.74       1     0.738        1    0     #>  8     8    35.5          1    35.5        1    35.5          0   25.5   #>  9     9    10.4          1    37.1        1    10.4          1    0.369 #> 10    10    10.5          1    32.7        1    10.5          1    0.464 #> # ℹ 194 more rows #> # ℹ 8 more variables: pfs.durn <dbl>, os.durn <dbl>, tzero <dbl>, #> #   pps.odurn <dbl>, pps.durn <dbl>, pps.flag <dbl>, ppd.durn <dbl>, #> #   ppd.flag <dbl>"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the ","title":"Find the ","text":"multiple survival regressions fitted endpoint dataset, necessary identify preferred model. function reviews fitted regressions selects minimum Akaike Bayesian Information Criterion (AIC, BIC), depending user choice. Model fits must parametric splines.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the ","text":"","code":"find_bestfit(reglist, crit)"},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the ","text":"reglist List fitted survival regressions endpoint dataset. crit Criterion used selection best fit, either \"aic\" (Akaike Information Criterion) \"bic\" (Bayesian Information Criterion).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the ","text":"List single survival regression best fit.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/find_bestfit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the ","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") # Parametric modeling fits_par <- fit_ends_mods_par(bosonc) find_bestfit(fits_par$ttp, \"aic\") #> $fit #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  -0.0376  -0.0652  -0.0101   0.0141 #> rate    0.0603   0.0455   0.0800   0.0087 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3123, df = 2 #> AIC = 846.6246 #>  #>  #> $results #> # A tibble: 6 × 13 #>      id valid conv  posdef  npts dists     pars loglik   aic   bic    ic rankaic #>   <int> <lgl> <lgl> <lgl>  <dbl> <chr>    <dbl>  <dbl> <dbl> <dbl> <dbl>   <dbl> #> 1     1 TRUE  TRUE  TRUE     204 exp          1  -426.  853.  856.  853.       6 #> 2     2 TRUE  TRUE  TRUE     204 weibull…     2  -423.  850.  857.  850.       3 #> 3     3 TRUE  TRUE  TRUE     204 llogis       2  -422.  848.  855.  848.       2 #> 4     4 TRUE  TRUE  TRUE     204 lnorm        2  -424.  851.  858.  851.       5 #> 5     5 TRUE  TRUE  TRUE     204 gamma        2  -424.  851.  858.  851.       4 #> 6     6 TRUE  TRUE  TRUE     204 gompertz     2  -421.  847.  853.  847.       1 #> # ℹ 1 more variable: rankbic <dbl> #>  # \\donttest{ # Splines modeling fits_spl <- fit_ends_mods_spl(bosonc) find_bestfit(fits_spl$ttp, \"bic\") #> $fit #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.60314  -1.83224  -1.37404   0.11689 #> gamma1   0.38216   0.20690   0.55743   0.08942 #> gamma2  -0.01936  -0.03709  -0.00163   0.00905 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.5655, df = 3 #> AIC = 849.1309 #>  #>  #> $results #> # A tibble: 9 × 14 #>      id valid conv  posdef  npts scales nknots  pars loglik   aic   bic    ic #>   <int> <lgl> <lgl> <lgl>  <dbl> <chr>   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> #> 1     1 TRUE  TRUE  TRUE     204 hazard      1     3  -423.  852.  862.  862. #> 2     2 TRUE  TRUE  TRUE     204 odds        1     3  -422.  849.  859.  859. #> 3     3 TRUE  TRUE  TRUE     204 normal      1     3  -422.  849.  859.  859. #> 4     4 TRUE  TRUE  TRUE     204 hazard      2     4  -423.  854.  867.  867. #> 5     5 TRUE  TRUE  TRUE     204 odds        2     4  -421.  851.  864.  864. #> 6     6 TRUE  TRUE  TRUE     204 normal      2     4  -421.  851.  864.  864. #> 7     7 TRUE  TRUE  TRUE     204 hazard      3     5  -420.  850.  867.  867. #> 8     8 TRUE  TRUE  TRUE     204 odds        3     5  -420.  850.  867.  867. #> 9     9 TRUE  TRUE  TRUE     204 normal      3     5  -420.  850.  867.  867. #> # ℹ 2 more variables: rankaic <dbl>, rankbic <dbl> #>  # }"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"Fits multiple parametric survival regressions, according distributions stipulated, multiple endpoints required fitting partitioned survival analysis, clock forward clock reset semi-markov models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"","code":"fit_ends_mods_par(   simdat,   cuttime = 0,   ppd.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   ttp.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pfs.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   os.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pps_cf.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   pps_cr.dist = c(\"exp\", \"weibullPH\", \"llogis\", \"lnorm\", \"gamma\", \"gompertz\"),   expvar = NA )"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"simdat Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. cuttime Cut-time two-piece model, equals zero one-piece models. ppd.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Pre-Progression Death (PPD). ttp.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Time Progression (TTP). pfs.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Progression-Free Survival (PFS). os.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Overall Survival (OS). pps_cf.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Post Progression Survival, time baseline (clock forward). pps_cr.dist Vector distributions (named per flexsurv::flexsurvreg()) fitted Post Progression Survival, time progression (clock reset). expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"list endpoint, distribution, containing two components: result: list class flexsurvreg containing information fitted model. error: error message returned fitting regression (NULL indicates error).","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit multiple parametric survival regressions to the multiple required endpoints — fit_ends_mods_par","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fit_ends_mods_par(bosonc, expvar=bosonc$ttp.durn) #> $ttp #> $ttp[[1]] #> $ttp[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est     L95%    U95%    se     #> rate  0.0437  0.0360  0.0530  0.0043 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -425.5134, df = 1 #> AIC = 853.0269 #>  #>  #> $ttp[[1]]$error #> NULL #>  #>  #> $ttp[[2]] #> $ttp[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.8379  0.7110  0.9875  0.0702 #> scale  0.0680  0.0448  0.1033  0.0145 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.0927, df = 2 #> AIC = 850.1853 #>  #>  #> $ttp[[2]]$error #> NULL #>  #>  #> $ttp[[3]] #> $ttp[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape   1.0300   0.8726   1.2158   0.0872 #> scale  15.4175  11.8479  20.0625   2.0716 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.068, df = 2 #> AIC = 848.136 #>  #>  #> $ttp[[3]]$error #> NULL #>  #>  #> $ttp[[4]] #> $ttp[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  2.762  2.462  3.062  0.153 #> sdlog    1.777  1.535  2.057  0.133 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.7432, df = 2 #> AIC = 851.4864 #>  #>  #> $ttp[[4]]$error #> NULL #>  #>  #> $ttp[[5]] #> $ttp[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.80871  0.65294  1.00164  0.08828 #> rate   0.03166  0.02120  0.04730  0.00649 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -423.5205, df = 2 #> AIC = 851.0411 #>  #>  #> $ttp[[5]]$error #> NULL #>  #>  #> $ttp[[6]] #> $ttp[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  -0.0376  -0.0652  -0.0101   0.0141 #> rate    0.0603   0.0455   0.0800   0.0087 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3123, df = 2 #> AIC = 846.6246 #>  #>  #> $ttp[[6]]$error #> NULL #>  #>  #>  #> $ppd #> $ppd[[1]] #> $ppd[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.01229  0.00854  0.01769  0.00228 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -156.5603, df = 1 #> AIC = 315.1206 #>  #>  #> $ppd[[1]]$error #> NULL #>  #>  #> $ppd[[2]] #> $ppd[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  1.43500  1.09372  1.88278  0.19884 #> scale  0.00352  0.00105  0.01183  0.00218 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7336, df = 2 #> AIC = 311.4673 #>  #>  #> $ppd[[2]]$error #> NULL #>  #>  #> $ppd[[3]] #> $ppd[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape   1.553   1.174   2.055   0.222 #> scale  43.036  29.365  63.072   8.393 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0749, df = 2 #> AIC = 312.1498 #>  #>  #> $ppd[[3]]$error #> NULL #>  #>  #> $ppd[[4]] #> $ppd[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  3.923  3.450  4.397  0.242 #> sdlog    1.289  0.993  1.674  0.172 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.541, df = 2 #> AIC = 313.0821 #>  #>  #> $ppd[[4]]$error #> NULL #>  #>  #> $ppd[[5]] #> $ppd[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  1.5585  1.0961  2.2159  0.2799 #> rate   0.0303  0.0152  0.0605  0.0107 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7877, df = 2 #> AIC = 311.5754 #>  #>  #> $ppd[[5]]$error #> NULL #>  #>  #> $ppd[[6]] #> $ppd[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.03933  0.00680  0.07185  0.01659 #> rate   0.00777  0.00436  0.01385  0.00229 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.1277, df = 2 #> AIC = 312.2554 #>  #>  #> $ppd[[6]]$error #> NULL #>  #>  #>  #> $pfs #> $pfs[[1]] #> $pfs[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.05596  0.04718  0.06637  0.00487 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.5726, df = 1 #> AIC = 1027.145 #>  #>  #> $pfs[[1]]$error #> NULL #>  #>  #> $pfs[[2]] #> $pfs[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  0.9313  0.8080  1.0733  0.0675 #> scale  0.0676  0.0453  0.1009  0.0138 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0729, df = 2 #> AIC = 1028.146 #>  #>  #> $pfs[[2]]$error #> NULL #>  #>  #> $pfs[[3]] #> $pfs[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape   1.1921   1.0310   1.3784   0.0883 #> scale  11.4917   9.3244  14.1628   1.2254 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -513.4304, df = 2 #> AIC = 1030.861 #>  #>  #> $pfs[[3]]$error #> NULL #>  #>  #> $pfs[[4]] #> $pfs[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est    L95%   U95%   se    #> meanlog  2.412  2.179  2.645  0.119 #> sdlog    1.535  1.353  1.742  0.099 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -516.8304, df = 2 #> AIC = 1037.661 #>  #>  #> $pfs[[4]]$error #> NULL #>  #>  #> $pfs[[5]] #> $pfs[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.91518  0.75087  1.11544  0.09240 #> rate   0.04985  0.03633  0.06840  0.00805 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.1786, df = 2 #> AIC = 1028.357 #>  #>  #> $pfs[[5]]$error #> NULL #>  #>  #> $pfs[[6]] #> $pfs[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est       L95%      U95%      se       #> shape  -0.01338  -0.03435   0.00759   0.01070 #> rate    0.06342   0.04926   0.08165   0.00817 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7442, df = 2 #> AIC = 1027.488 #>  #>  #> $pfs[[6]]$error #> NULL #>  #>  #>  #> $os #> $os[[1]] #> $os[[1]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>       est      L95%     U95%     se      #> rate  0.02788  0.02285  0.03402  0.00283 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -444.2435, df = 1 #> AIC = 890.4871 #>  #>  #> $os[[1]]$error #> NULL #>  #>  #> $os[[2]] #> $os[[2]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  1.51432  1.29287  1.77369  0.12215 #> scale  0.00559  0.00254  0.01233  0.00226 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.3483, df = 2 #> AIC = 870.6965 #>  #>  #> $os[[2]]$error #> NULL #>  #>  #> $os[[3]] #> $os[[3]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape   1.814   1.541   2.136   0.151 #> scale  23.832  20.361  27.895   1.914 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -436.9493, df = 2 #> AIC = 877.8987 #>  #>  #> $os[[3]]$error #> NULL #>  #>  #> $os[[4]] #> $os[[4]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>          est     L95%    U95%    se     #> meanlog  3.1627  2.9845  3.3409  0.0909 #> sdlog    1.0166  0.8806  1.1734  0.0744 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -439.3941, df = 2 #> AIC = 882.7881 #>  #>  #> $os[[4]]$error #> NULL #>  #>  #> $os[[5]] #> $os[[5]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est     L95%    U95%    se     #> shape  1.7620  1.3981  2.2207  0.2080 #> rate   0.0605  0.0435  0.0842  0.0102 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -434.1308, df = 2 #> AIC = 872.2617 #>  #>  #> $os[[5]]$error #> NULL #>  #>  #> $os[[6]] #> $os[[6]]$result #> Call: #> .f(formula = ..1, dist = ..2) #>  #> Estimates:  #>        est      L95%     U95%     se      #> shape  0.04179  0.02473  0.05885  0.00871 #> rate   0.01532  0.01079  0.02174  0.00274 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.9344, df = 2 #> AIC = 871.8687 #>  #>  #> $os[[6]]$error #> NULL #>  #>  #>  #> $pps_cf #> $pps_cf[[1]] #> $pps_cf[[1]]$result #> NULL #>  #> $pps_cf[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[2]] #> $pps_cf[[2]]$result #> NULL #>  #> $pps_cf[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[3]] #> $pps_cf[[3]]$result #> NULL #>  #> $pps_cf[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[4]] #> $pps_cf[[4]]$result #> NULL #>  #> $pps_cf[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[5]] #> $pps_cf[[5]]$result #> NULL #>  #> $pps_cf[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[6]] #> $pps_cf[[6]]$result #> NULL #>  #> $pps_cf[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>  #> $pps_cr #> $pps_cr[[1]] #> $pps_cr[[1]]$result #> NULL #>  #> $pps_cr[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[2]] #> $pps_cr[[2]]$result #> NULL #>  #> $pps_cr[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[3]] #> $pps_cr[[3]]$result #> NULL #>  #> $pps_cr[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[4]] #> $pps_cr[[4]]$result #> NULL #>  #> $pps_cr[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[5]] #> $pps_cr[[5]]$result #> NULL #>  #> $pps_cr[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[6]] #> $pps_cr[[6]]$result #> NULL #>  #> $pps_cr[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"Fits multiple survival regressions, according distributions stipulated, multiple endpoints required fitting partitioned survival analysis, clock forward clock reset semi-markov models.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"","code":"fit_ends_mods_spl(   simdat,   knot_set = 1:3,   scale_set = c(\"hazard\", \"odds\", \"normal\"),   expvar = NA )"},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"simdat Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. knot_set vector numbers knots consider, following flexsurv::flexsurvspline()). scale_set vector spline scales consider, following flexsurv::flexsurvspline()). expvar Explanatory variable modeling PPS","code":""},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"list endpoint, distribution, containing two components: result: list class flexsurv::flexsurvspline containing information fitted model. error: error message returned fitting regression (NULL indicates error). Also, given cuttime.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/fit_ends_mods_spl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit multiple spline regressions to the multiple required endpoints — fit_ends_mods_spl","text":"","code":"# \\donttest{ # Create dataset in suitable form using bos dataset from the flexsurv package bosonc <- create_dummydata(\"flexbosms\") fit_ends_mods_spl(bosonc, expvar=bosonc$ttp.durn) #> $ttp #> $ttp[[1]] #> $ttp[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7114  -3.1392  -2.2836   0.2183 #> gamma1   0.9650   0.5632   1.3668   0.2050 #> gamma2   0.0110  -0.0211   0.0432   0.0164 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.8569, df = 3 #> AIC = 851.7137 #>  #>  #> $ttp[[1]]$error #> NULL #>  #>  #> $ttp[[2]] #> $ttp[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.8065  -3.2682  -2.3448   0.2356 #> gamma1   0.8694   0.4668   1.2720   0.2054 #> gamma2  -0.0153  -0.0511   0.0205   0.0183 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.7298, df = 3 #> AIC = 849.4597 #>  #>  #> $ttp[[2]]$error #> NULL #>  #>  #> $ttp[[3]] #> $ttp[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.60314  -1.83224  -1.37404   0.11689 #> gamma1   0.38216   0.20690   0.55743   0.08942 #> gamma2  -0.01936  -0.03709  -0.00163   0.00905 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.5655, df = 3 #> AIC = 849.1309 #>  #>  #> $ttp[[3]]$error #> NULL #>  #>  #> $ttp[[4]] #> $ttp[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.73940  -3.27510  -2.20370   0.27332 #> gamma1   0.94983   0.43830   1.46135   0.26098 #> gamma2  -0.00852  -0.14676   0.12973   0.07053 #> gamma3   0.02978  -0.19546   0.25502   0.11492 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -422.8021, df = 4 #> AIC = 853.6043 #>  #>  #> $ttp[[4]]$error #> NULL #>  #>  #> $ttp[[5]] #> $ttp[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6568  -3.2137  -2.1000   0.2841 #> gamma1   1.0097   0.4700   1.5495   0.2754 #> gamma2   0.0691  -0.0964   0.2346   0.0844 #> gamma3  -0.1375  -0.4197   0.1448   0.1440 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3791, df = 4 #> AIC = 850.7583 #>  #>  #> $ttp[[5]]$error #> NULL #>  #>  #> $ttp[[6]] #> $ttp[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.5359  -1.8178  -1.2539   0.1439 #> gamma1   0.4345   0.2068   0.6622   0.1162 #> gamma2   0.0304  -0.0583   0.1190   0.0452 #> gamma3  -0.0796  -0.2359   0.0768   0.0798 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -421.3112, df = 4 #> AIC = 850.6223 #>  #>  #> $ttp[[6]]$error #> NULL #>  #>  #> $ttp[[7]] #> $ttp[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est        L95%       U95%       se        #> gamma0  -2.485963  -3.046933  -1.924993   0.286214 #> gamma1   1.197935   0.554813   1.841057   0.328130 #> gamma2   0.221183   0.000829   0.441538   0.112428 #> gamma3  -0.837151  -1.573248  -0.101055   0.375566 #> gamma4   0.887201   0.107971   1.666432   0.397574 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.1814, df = 5 #> AIC = 850.3627 #>  #>  #> $ttp[[7]]$error #> NULL #>  #>  #> $ttp[[8]] #> $ttp[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.4671  -3.0586  -1.8755   0.3018 #> gamma1   1.1985   0.5473   1.8496   0.3322 #> gamma2   0.2335  -0.0139   0.4809   0.1262 #> gamma3  -0.7797  -1.6893   0.1298   0.4641 #> gamma4   0.7355  -0.2786   1.7496   0.5174 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.0042, df = 5 #> AIC = 850.0085 #>  #>  #> $ttp[[8]]$error #> NULL #>  #>  #> $ttp[[9]] #> $ttp[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.4492  -1.7515  -1.1470   0.1542 #> gamma1   0.5042   0.2406   0.7677   0.1345 #> gamma2   0.1192  -0.0130   0.2514   0.0674 #> gamma3  -0.4462  -0.9748   0.0824   0.2697 #> gamma4   0.4287  -0.1742   1.0316   0.3076 #>  #> N = 204,  Events: 103,  Censored: 101 #> Total time at risk: 2358.845 #> Log-likelihood = -420.0067, df = 5 #> AIC = 850.0134 #>  #>  #> $ttp[[9]]$error #> NULL #>  #>  #>  #> $ppd #> $ppd[[1]] #> $ppd[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.8254  -7.7259  -3.9250   0.9696 #> gamma1   1.5623   0.4569   2.6676   0.5640 #> gamma2   0.0167  -0.1170   0.1504   0.0682 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.7031, df = 3 #> AIC = 313.4063 #>  #>  #> $ppd[[1]]$error #> NULL #>  #>  #> $ppd[[2]] #> $ppd[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -5.79819  -7.70574  -3.89064   0.97326 #> gamma1   1.52049   0.39352   2.64746   0.57499 #> gamma2  -0.00446  -0.14762   0.13870   0.07304 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0731, df = 3 #> AIC = 314.1461 #>  #>  #> $ppd[[2]]$error #> NULL #>  #>  #> $ppd[[3]] #> $ppd[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7953  -3.4937  -2.0969   0.3563 #> gamma1   0.5645   0.1203   1.0088   0.2267 #> gamma2  -0.0331  -0.0986   0.0324   0.0334 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -154.0678, df = 3 #> AIC = 314.1356 #>  #>  #> $ppd[[3]]$error #> NULL #>  #>  #> $ppd[[4]] #> $ppd[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.260  -8.623  -3.897   1.206 #> gamma1   2.080   0.308   3.852   0.904 #> gamma2   0.404  -0.502   1.309   0.462 #> gamma3  -0.433  -1.434   0.569   0.511 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.3264, df = 4 #> AIC = 314.6528 #>  #>  #> $ppd[[4]]$error #> NULL #>  #>  #> $ppd[[5]] #> $ppd[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.279  -8.668  -3.891   1.219 #> gamma1   2.108   0.301   3.916   0.922 #> gamma2   0.487  -0.491   1.465   0.499 #> gamma3  -0.560  -1.666   0.545   0.564 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5727, df = 4 #> AIC = 315.1455 #>  #>  #> $ppd[[5]]$error #> NULL #>  #>  #> $ppd[[6]] #> $ppd[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -2.920  -3.724  -2.115   0.410 #> gamma1   0.757   0.108   1.405   0.331 #> gamma2   0.207  -0.254   0.669   0.236 #> gamma3  -0.287  -0.839   0.266   0.282 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.6044, df = 4 #> AIC = 315.2088 #>  #>  #> $ppd[[6]]$error #> NULL #>  #>  #> $ppd[[7]] #> $ppd[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -6.3287  -8.9746  -3.6827   1.3500 #> gamma1   2.1917  -0.2409   4.6243   1.2411 #> gamma2   0.2345  -1.2648   1.7337   0.7649 #> gamma3   0.0531  -2.7173   2.8235   1.4135 #> gamma4  -0.3086  -2.3272   1.7101   1.0299 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.3243, df = 5 #> AIC = 316.6486 #>  #>  #> $ppd[[7]]$error #> NULL #>  #>  #> $ppd[[8]] #> $ppd[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -6.320  -8.969  -3.671   1.352 #> gamma1   2.182  -0.262   4.626   1.247 #> gamma2   0.223  -1.329   1.775   0.792 #> gamma3   0.174  -2.806   3.154   1.521 #> gamma4  -0.487  -2.746   1.772   1.153 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5704, df = 5 #> AIC = 317.1408 #>  #>  #> $ppd[[8]]$error #> NULL #>  #>  #> $ppd[[9]] #> $ppd[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.89719  -3.73120  -2.06319   0.42552 #> gamma1   0.71931  -0.08609   1.52472   0.41093 #> gamma2   0.00886  -0.65672   0.67443   0.33959 #> gamma3   0.24938  -1.22124   1.71999   0.75033 #> gamma4  -0.38355  -1.60015   0.83305   0.62073 #>  #> N = 204,  Events: 29,  Censored: 175 #> Total time at risk: 2358.845 #> Log-likelihood = -153.5862, df = 5 #> AIC = 317.1723 #>  #>  #> $ppd[[9]]$error #> NULL #>  #>  #>  #> $pfs #> $pfs[[1]] #> $pfs[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -2.71386  -3.13361  -2.29411   0.21416 #> gamma1   0.99398   0.61132   1.37664   0.19524 #> gamma2   0.00393  -0.01838   0.02623   0.01138 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -512.0123, df = 3 #> AIC = 1030.025 #>  #>  #> $pfs[[1]]$error #> NULL #>  #>  #> $pfs[[2]] #> $pfs[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est        L95%       U95%       se        #> gamma0  -2.848058  -3.298634  -2.397482   0.229890 #> gamma1   0.832337   0.449968   1.214706   0.195090 #> gamma2  -0.025453  -0.051358   0.000453   0.013217 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.7148, df = 3 #> AIC = 1029.43 #>  #>  #> $pfs[[2]]$error #> NULL #>  #>  #> $pfs[[3]] #> $pfs[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est       L95%      U95%      se       #> gamma0  -1.62401  -1.84681  -1.40122   0.11367 #> gamma1   0.37082   0.20155   0.54008   0.08636 #> gamma2  -0.02243  -0.03539  -0.00947   0.00661 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.4637, df = 3 #> AIC = 1028.927 #>  #>  #> $pfs[[3]]$error #> NULL #>  #>  #> $pfs[[4]] #> $pfs[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7744  -3.2640  -2.2848   0.2498 #> gamma1   0.9271   0.4496   1.4046   0.2436 #> gamma2  -0.0307  -0.1621   0.1006   0.0670 #> gamma3   0.0441  -0.1240   0.2122   0.0858 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.8845, df = 4 #> AIC = 1031.769 #>  #>  #> $pfs[[4]]$error #> NULL #>  #>  #> $pfs[[5]] #> $pfs[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.7070  -3.2250  -2.1890   0.2643 #> gamma1   0.9774   0.4707   1.4841   0.2585 #> gamma2   0.0822  -0.0934   0.2577   0.0896 #> gamma3  -0.1403  -0.3779   0.0973   0.1212 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.2509, df = 4 #> AIC = 1030.502 #>  #>  #> $pfs[[5]]$error #> NULL #>  #>  #> $pfs[[6]] #> $pfs[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.5724  -1.8376  -1.3072   0.1353 #> gamma1   0.4129   0.1989   0.6270   0.1092 #> gamma2   0.0272  -0.0673   0.1217   0.0482 #> gamma3  -0.0637  -0.1942   0.0668   0.0666 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -511.2899, df = 4 #> AIC = 1030.58 #>  #>  #> $pfs[[6]]$error #> NULL #>  #>  #> $pfs[[7]] #> $pfs[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5410  -3.0590  -2.0230   0.2643 #> gamma1   1.1468   0.5509   1.7427   0.3040 #> gamma2   0.1899  -0.0307   0.4104   0.1125 #> gamma3  -0.7089  -1.3939  -0.0238   0.3495 #> gamma4   0.6196   0.0378   1.2013   0.2968 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -509.8239, df = 5 #> AIC = 1029.648 #>  #>  #> $pfs[[7]]$error #> NULL #>  #>  #> $pfs[[8]] #> $pfs[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5276  -3.0767  -1.9784   0.2802 #> gamma1   1.1501   0.5431   1.7570   0.3097 #> gamma2   0.2371  -0.0218   0.4960   0.1321 #> gamma3  -0.7336  -1.6567   0.1896   0.4710 #> gamma4   0.5475  -0.2959   1.3910   0.4303 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -510.0705, df = 5 #> AIC = 1030.141 #>  #>  #> $pfs[[8]]$error #> NULL #>  #>  #> $pfs[[9]] #> $pfs[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -1.4793  -1.7636  -1.1950   0.1450 #> gamma1   0.4844   0.2357   0.7330   0.1269 #> gamma2   0.1297  -0.0121   0.2716   0.0724 #> gamma3  -0.4727  -1.0114   0.0660   0.2749 #> gamma4   0.3763  -0.1221   0.8746   0.2543 #>  #> N = 204,  Events: 132,  Censored: 72 #> Total time at risk: 2358.845 #> Log-likelihood = -509.868, df = 5 #> AIC = 1029.736 #>  #>  #> $pfs[[9]]$error #> NULL #>  #>  #>  #> $os #> $os[[1]] #> $os[[1]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.0074  -6.2393  -3.7754   0.6286 #> gamma1   1.3996   0.7437   2.0556   0.3347 #> gamma2  -0.0157  -0.0995   0.0682   0.0428 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.2801, df = 3 #> AIC = 872.5603 #>  #>  #> $os[[1]]$error #> NULL #>  #>  #> $os[[2]] #> $os[[2]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -4.8971  -6.1132  -3.6809   0.6205 #> gamma1   1.2418   0.5761   1.9075   0.3396 #> gamma2  -0.0854  -0.1808   0.0101   0.0487 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -435.5343, df = 3 #> AIC = 877.0686 #>  #>  #> $os[[2]]$error #> NULL #>  #>  #> $os[[3]] #> $os[[3]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.5243  -3.0238  -2.0248   0.2549 #> gamma1   0.5252   0.2308   0.8195   0.1502 #> gamma2  -0.0771  -0.1250  -0.0292   0.0245 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -434.7993, df = 3 #> AIC = 875.5985 #>  #>  #> $os[[3]]$error #> NULL #>  #>  #> $os[[4]] #> $os[[4]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.321  -6.770  -3.872   0.739 #> gamma1   1.745   0.799   2.692   0.483 #> gamma2   0.299  -0.208   0.807   0.259 #> gamma3  -0.402  -1.050   0.246   0.331 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.5721, df = 4 #> AIC = 873.1442 #>  #>  #> $os[[4]]$error #> NULL #>  #>  #> $os[[5]] #> $os[[5]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.369  -6.851  -3.886   0.757 #> gamma1   1.807   0.817   2.797   0.505 #> gamma2   0.614  -0.020   1.249   0.324 #> gamma3  -0.930  -1.784  -0.076   0.436 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.4306, df = 4 #> AIC = 874.8611 #>  #>  #> $os[[5]]$error #> NULL #>  #>  #> $os[[6]] #> $os[[6]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6769  -3.2520  -2.1018   0.2934 #> gamma1   0.7502   0.3378   1.1625   0.2104 #> gamma2   0.3136  -0.0281   0.6553   0.1743 #> gamma3  -0.5287  -1.0036  -0.0538   0.2423 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.8091, df = 4 #> AIC = 873.6182 #>  #>  #> $os[[6]]$error #> NULL #>  #>  #> $os[[7]] #> $os[[7]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est     L95%    U95%    se     #> gamma0  -5.426  -6.984  -3.868   0.795 #> gamma1   1.879   0.738   3.019   0.582 #> gamma2   0.318  -0.573   1.209   0.455 #> gamma3  -0.275  -2.322   1.772   1.044 #> gamma4  -0.117  -1.820   1.587   0.869 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.4254, df = 5 #> AIC = 874.8508 #>  #>  #> $os[[7]]$error #> NULL #>  #>  #> $os[[8]] #> $os[[8]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -5.4331  -7.0056  -3.8607   0.8023 #> gamma1   1.8919   0.7269   3.0570   0.5944 #> gamma2   0.3778  -0.6283   1.3840   0.5134 #> gamma3   0.0734  -2.4752   2.6220   1.3003 #> gamma4  -0.8477  -3.1700   1.4745   1.1848 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -433.2146, df = 5 #> AIC = 876.4292 #>  #>  #> $os[[8]]$error #> NULL #>  #>  #> $os[[9]] #> $os[[9]]$result #> Call: #> .f(formula = ..1, k = ..2, scale = ..3) #>  #> Estimates:  #>         est      L95%     U95%     se      #> gamma0  -2.6970  -3.2959  -2.0981   0.3056 #> gamma1   0.7819   0.3067   1.2570   0.2424 #> gamma2   0.1897  -0.3455   0.7250   0.2731 #> gamma3   0.0191  -1.4401   1.4784   0.7446 #> gamma4  -0.4670  -1.8384   0.9043   0.6997 #>  #> N = 204,  Events: 97,  Censored: 107 #> Total time at risk: 3479.143 #> Log-likelihood = -432.6368, df = 5 #> AIC = 875.2736 #>  #>  #> $os[[9]]$error #> NULL #>  #>  #>  #> $pps_cf #> $pps_cf[[1]] #> $pps_cf[[1]]$result #> NULL #>  #> $pps_cf[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[2]] #> $pps_cf[[2]]$result #> NULL #>  #> $pps_cf[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[3]] #> $pps_cf[[3]]$result #> NULL #>  #> $pps_cf[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[4]] #> $pps_cf[[4]]$result #> NULL #>  #> $pps_cf[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[5]] #> $pps_cf[[5]]$result #> NULL #>  #> $pps_cf[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[6]] #> $pps_cf[[6]]$result #> NULL #>  #> $pps_cf[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[7]] #> $pps_cf[[7]]$result #> NULL #>  #> $pps_cf[[7]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[8]] #> $pps_cf[[8]]$result #> NULL #>  #> $pps_cf[[8]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cf[[9]] #> $pps_cf[[9]]$result #> NULL #>  #> $pps_cf[[9]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>  #> $pps_cr #> $pps_cr[[1]] #> $pps_cr[[1]]$result #> NULL #>  #> $pps_cr[[1]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[2]] #> $pps_cr[[2]]$result #> NULL #>  #> $pps_cr[[2]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[3]] #> $pps_cr[[3]]$result #> NULL #>  #> $pps_cr[[3]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[4]] #> $pps_cr[[4]]$result #> NULL #>  #> $pps_cr[[4]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[5]] #> $pps_cr[[5]]$result #> NULL #>  #> $pps_cr[[5]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[6]] #> $pps_cr[[6]]$result #> NULL #>  #> $pps_cr[[6]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[7]] #> $pps_cr[[7]]$result #> NULL #>  #> $pps_cr[[7]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[8]] #> $pps_cr[[8]]$result #> NULL #>  #> $pps_cr[[8]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #> $pps_cr[[9]] #> $pps_cr[[9]]$result #> NULL #>  #> $pps_cr[[9]]$error #> <simpleError in model.frame.default(formula = survival::Surv(time = durn1, time2 = durn2,     event = evflag) ~ {    {        expvar    }}, data = <environment>): variable lengths differ (found for '{     {         expvar     } }')> #>  #>  #>  # }"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the PSM hazard functions — graph_psm_hazards","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"Graph PSM hazard functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"","code":"graph_psm_hazards(timevar, endpoint, ptdata, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"timevar Vector times calculate hazards endpoint Endpoint hazard required (TTP, PPD, PFS, OS PPS) ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"List containing: adj hazard adjusted constraints unadj unadjusted hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_hazards.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the PSM hazard functions — graph_psm_hazards","text":"","code":"bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) # Create graphics # psmh_simple <- graph_psm_hazards( #   timerange=(0:10)*6, #   endpoint=\"OS\", #   dpam=params, #   psmtype=\"simple\") # psmh_simple$graph"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the PSM survival functions — graph_psm_survs","title":"Graph the PSM survival functions — graph_psm_survs","text":"Graph PSM survival functions","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the PSM survival functions — graph_psm_survs","text":"","code":"graph_psm_survs(timevar, endpoint, ptdata, dpam, psmtype)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the PSM survival functions — graph_psm_survs","text":"timevar Vector times calculate hazards endpoint Endpoint hazard required (TTP, PPD, PFS, OS PPS) ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). psmtype Either \"simple\" \"complex\" PSM formulation","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the PSM survival functions — graph_psm_survs","text":"List containing: adj hazard adjusted constraints unadj unadjusted hazard","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_psm_survs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the PSM survival functions — graph_psm_survs","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) # Graphic illustrating effect of constraints on OS model psms_simple <- graph_psm_survs(   timevar=6*(0:10),   endpoint=\"OS\",   ptdata=bosonc,   dpam=params,   psmtype=\"simple\" ) psms_simple$graph  # }"},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph the observed and fitted state membership probabilities — graph_survs","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"Graph observed fitted state membership probabilities PF, PD, OS PPS.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"","code":"graph_survs(ptdata, dpam, cuttime = 0)"},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"ptdata Dataset patient level data. Must tibble columns named: ptid: patient identifier pfs.durn: duration PFS baseline pfs.flag: event flag PFS (=1 progression death occurred, 0 censoring) os.durn: duration OS baseline os.flag: event flag OS (=1 death occurred, 0 censoring) ttp.durn: duration TTP baseline (usually equal pfs.durn) ttp.flag: event flag TTP (=1 progression occurred, 0 censoring). Survival data endpoints (time progression, pre-progression death, post-progression survival) derived PFS OS. dpam List survival regressions endpoint: pre-progression death (PPD) time progression (TTP) progression-free survival (PFS) overall survival (OS) post-progression survival clock forward (PPS-CF) post-progression survival clock reset (PPS-CR). cuttime cut-time two-piece model (default 0, indicating one-piece model)","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"List two items follows. data tibble containing data derived used derivation graphics. graph list four graphics follows: pf: Membership probability PF (progression-free) state versus time since baseline, method pd: Membership probability PD (progressive disease) state versus time since baseline, method os: Probability alive versus time since baseline, method pps: Probability alive versus time since progression, method","code":""},{"path":"https://merck.github.io/psm3mkv/reference/graph_survs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph the observed and fitted state membership probabilities — graph_survs","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_par(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) # Create graphics gs <- graph_survs(ptdata=bosonc, dpam=params) gs$graph$pd #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`).  # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"Calculates membership probability alive particular time (vectorized), given either state transition model (clock forward clock reset) given statistical distributions parameters. sum membership probabilities progression free progressed disease states.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"","code":"prob_os_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include overall survival (OS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive in a partitioned survival model — prob_os_psm","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_os_psm(0:100, params) #>   [1] 1.000000000 0.993333811 0.982460429 0.969074887 0.953734324 0.936776991 #>   [7] 0.918449615 0.898950119 0.878446448 0.857086233 0.835002270 0.812315818 #>  [13] 0.789138714 0.765574757 0.741720655 0.717667076 0.693502704 0.669312345 #>  [19] 0.645174506 0.621161570 0.597339994 0.573770507 0.550508301 0.527603233 #>  [25] 0.505100023 0.483038462 0.461453625 0.440376084 0.419832131 0.399843999 #>  [31] 0.380430085 0.361605177 0.343380677 0.325764826 0.308762924 0.292377547 #>  [37] 0.276608761 0.261454330 0.246909917 0.232969284 0.219624475 0.206866001 #>  [43] 0.194683013 0.183063466 0.171994277 0.161461472 0.151450328 0.141945500 #>  [49] 0.132931146 0.124391040 0.116308675 0.108667364 0.101450325 0.094640765 #>  [55] 0.088221917 0.082177105 0.076489851 0.071143939 0.066123454 0.061412820 #>  [61] 0.056996834 0.052860693 0.048990017 0.045370867 0.041989763 0.038833690 #>  [67] 0.035890110 0.033146965 0.030592679 0.028216158 0.026006789 0.023954430 #>  [73] 0.022049410 0.020282517 0.018644991 0.017128511 0.015725185 0.014427539 #>  [79] 0.013228500 0.012121389 0.011099902 0.010158095 0.009290377 0.008491485 #>  [85] 0.007756480 0.007080727 0.006459880 0.005889871 0.005366897 0.004887403 #>  [91] 0.004448071 0.004045807 0.003677730 0.003341156 0.003033593 0.002752723 #>  [97] 0.002496397 0.002262621 0.002049549 0.001855470 0.001678803 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"Calculates membership probability alive given time (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"","code":"prob_os_stm_cf(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock forward model (PPS-CF). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive under the state transition clock forward model — prob_os_stm_cf","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_os_stm_cf(0:100, params) #>   [1] 1.00000000 0.99438187 0.98388723 0.97045962 0.95480239 0.93736449 #>   [7] 0.91847520 0.89839291 0.87733215 0.85547549 0.83298470 0.81000158 #>  [13] 0.78664786 0.76303528 0.73926205 0.71541805 0.69158476 0.66783743 #>  [19] 0.64424475 0.62087956 0.59781713 0.57511174 0.55281670 0.53097889 #>  [25] 0.50963525 0.48881683 0.46854870 0.44885041 0.42973671 0.41121802 #>  [31] 0.39330081 0.37598800 0.35927948 0.34317249 0.32766172 0.31273990 #>  [37] 0.29839789 0.28462513 0.27140962 0.25873850 0.24659790 0.23497329 #>  [43] 0.22384963 0.21321146 0.20304335 0.19332892 0.18405247 0.17519810 #>  [49] 0.16675002 0.15869261 0.15101046 0.14370296 0.13672548 0.13007897 #>  [55] 0.12374922 0.11772229 0.11197405 0.10651346 0.10131630 0.09637071 #>  [61] 0.09166506 0.08718819 0.08292942 0.07887846 0.07502548 0.07136107 #>  [67] 0.06787620 0.06456226 0.06141100 0.05841457 0.05556543 0.05285661 #>  [73] 0.05028089 0.04783192 0.04550350 0.04328969 0.04118485 0.03918361 #>  [79] 0.03728177 0.03547254 0.03375228 0.03211658 0.03056125 0.02908229 #>  [85] 0.02767592 0.02633852 0.02506668 0.02385712 0.02270676 0.02161266 #>  [91] 0.02057201 0.01958217 0.01864061 0.01774527 0.01689317 0.01608253 #>  [97] 0.01531128 0.01457750 0.01387931 0.01321495 0.01258276 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"Calculates membership probability alive given time (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"","code":"prob_os_stm_cr(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock reset model (PPS-CR). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_os_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being alive under the state transition clock reset model — prob_os_stm_cr","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_os_stm_cr(0:100, params) #>   [1] 1.00000000 0.99695476 0.98950782 0.97746752 0.96161310 0.94299857 #>   [7] 0.92254723 0.90090563 0.87846191 0.85545262 0.83203515 0.80832010 #>  [13] 0.78438687 0.76030439 0.73614308 0.71198223 0.68790283 0.66398489 #>  [19] 0.64030304 0.61692553 0.59392015 0.57133517 0.54921944 0.52761537 #>  [25] 0.50655596 0.48606814 0.46617256 0.44688418 0.42821302 0.41016450 #>  [31] 0.39274008 0.37593750 0.35975163 0.34417487 0.32919723 0.31480714 #>  [37] 0.30099142 0.28773575 0.27502473 0.26284252 0.25117260 0.23999818 #>  [43] 0.22930225 0.21906785 0.20927831 0.19991639 0.19096573 0.18241001 #>  [49] 0.17423324 0.16643504 0.15896917 0.15183686 0.14502391 0.13850405 #>  [55] 0.13228962 0.12635463 0.12068691 0.11527456 0.11010623 0.10517103 #>  [61] 0.10045851 0.09595866 0.09166190 0.08755905 0.08364158 0.07990060 #>  [67] 0.07632835 0.07291716 0.06965971 0.06654902 0.06357815 0.06074126 #>  [73] 0.05803193 0.05544476 0.05297372 0.05061357 0.04835939 0.04620636 #>  [79] 0.04414988 0.04218558 0.04031110 0.03851873 0.03680657 0.03517099 #>  [85] 0.03360852 0.03211587 0.03068988 0.02932754 0.02802600 0.02678250 #>  [91] 0.02559444 0.02445933 0.02337478 0.02233852 0.02134838 0.02040230 #>  [97] 0.01949830 0.01863449 0.01780908 0.01702035 0.01626666 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"Calculates membership probability progressed disease particular time (vectorized), given partitioned survival model certain statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"","code":"prob_pd_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include progression-free survival (PFS) overall survival (OS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate membership probability of progressed disease state in a partitioned survival model — prob_pd_psm","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pd_psm(0:100, params) #>   [1]  0.000000000  0.054213562  0.098565251  0.137013060  0.170266758 #>   [6]  0.198796057  0.223008955  0.243280274  0.259955242  0.273308351 #>  [11]  0.283582761  0.291034994  0.295922768  0.298496989  0.298997351 #>  [16]  0.297650474  0.294672507  0.290266681  0.284620862  0.277908013 #>  [21]  0.270286856  0.261902614  0.252887788  0.243362937  0.233437439 #>  [26]  0.223210226  0.212770498  0.202198385  0.191565592  0.180935996 #>  [31]  0.170366221  0.159906170  0.149599537  0.139484288  0.129593106 #>  [36]  0.119953824  0.110589822  0.101520409  0.092761177  0.084324333 #>  [41]  0.076219022  0.068451612  0.061025979  0.053943759  0.047204597 #>  [46]  0.040806365  0.034745377  0.029016580  0.023613739  0.018529600 #>  [51]  0.013756110  0.009284544  0.005105561  0.001209324 -0.002414425 #>  [56] -0.005776271 -0.008886978 -0.011757406 -0.014398443 -0.016820940 #>  [61] -0.019035660 -0.021053227 -0.022884090 -0.024538479 -0.026026384 #>  [66] -0.027357522 -0.028541320 -0.029586897 -0.030503052 -0.031298251 #>  [71] -0.031980622 -0.032557951 -0.033037680 -0.033426907 -0.033732387 #>  [76] -0.033960539 -0.034117447 -0.034208871 -0.034240252 -0.034216719 #>  [81] -0.034143102 -0.034023939 -0.033863488 -0.033665734 -0.033434406 #>  [86] -0.033172981 -0.032884702 -0.032572583 -0.032239423 -0.031887818 #>  [91] -0.031520167 -0.031138688 -0.030745425 -0.030342259 -0.029930916 #>  [96] -0.029512981 -0.029089899 -0.028662992 -0.028233462 -0.027802399 #> [101] -0.027370792 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"Calculates membership probability progressed disease state given time (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"","code":"prob_pd_stm_cf(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock forward model (PPS-CF). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of having progressed disease under the state transition clock forward model — prob_pd_stm_cf","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pd_stm_cf(0:100, params) #>   [1] 0.000000000 0.057565843 0.102501319 0.140011833 0.171674410 0.198397032 #>   [7] 0.220826251 0.239465829 0.254684897 0.266784588 0.276064470 0.282811290 #>  [13] 0.287292879 0.289760924 0.290444507 0.289554760 0.287284771 0.283812230 #>  [19] 0.279299653 0.273905726 0.267784327 0.261061641 0.253856894 0.246277388 #>  [25] 0.238415524 0.230353913 0.222165759 0.213914700 0.205655880 0.197436766 #>  [31] 0.189297938 0.181273752 0.173393123 0.165680168 0.158154467 0.150831878 #>  [37] 0.143724753 0.136842555 0.130191950 0.123777527 0.117601707 0.111665238 #>  [43] 0.105967356 0.100506051 0.095278476 0.090280111 0.085506406 0.080951979 #>  [49] 0.076610924 0.072476967 0.068543515 0.064818251 0.061264396 0.057890339 #>  [55] 0.054688924 0.051652873 0.048764410 0.046038487 0.043456604 0.041012315 #>  [61] 0.038699151 0.036510856 0.034441387 0.032484908 0.030635803 0.028888675 #>  [67] 0.027238338 0.025679816 0.024208354 0.022819395 0.021508584 0.020271953 #>  [73] 0.019105157 0.018004616 0.016966732 0.015988084 0.015065419 0.014195646 #>  [79] 0.013376758 0.012604047 0.011875869 0.011189720 0.010543227 0.009934145 #>  [85] 0.009360347 0.008819822 0.008310665 0.007831078 0.007379362 0.006953909 #>  [91] 0.006553202 0.006175811 0.005820382 0.005485971 0.005170675 0.004873730 #>  [97] 0.004594067 0.004330694 0.004082633 0.003848996 0.003628937 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"Calculates membership probability progressed disease state given time (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"","code":"prob_pd_stm_cr(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"time Time (numeric vectorized) baseline. dpam List survival regressions model endpoints. must include pre-progression death (PPD), time progression (TTP) post progression survival calculated clock reset model (PPS-CR). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pd_stm_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of having progressed disease under the state transition clock reset model — prob_pd_stm_cr","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pd_stm_cr(0:100, params) #>   [1] 0.000000000 0.060138735 0.108121914 0.147019738 0.178485112 0.204031115 #>   [7] 0.224898274 0.241978542 0.255814655 0.266761717 0.275114914 0.281129804 #>  [13] 0.285031884 0.287030029 0.287325545 0.286118938 0.283602846 0.279959691 #>  [19] 0.275357940 0.269951702 0.263887342 0.257285072 0.250259636 0.242913869 #>  [25] 0.235336236 0.227605222 0.219789614 0.211948479 0.204132184 0.196383250 #>  [31] 0.188737209 0.181223250 0.173865274 0.166682547 0.159689972 0.152899110 #>  [37] 0.146318278 0.139953175 0.133807059 0.127881545 0.122176413 0.116690118 #>  [43] 0.111419978 0.106362436 0.101513431 0.096867583 0.092419669 0.088163888 #>  [49] 0.084094142 0.080219398 0.076502228 0.072952148 0.069562820 0.066315417 #>  [55] 0.063229318 0.060285215 0.057477267 0.054799591 0.052246535 0.049812641 #>  [61] 0.047492604 0.045281319 0.043173866 0.041165500 0.039251895 0.037428207 #>  [67] 0.035690487 0.034034715 0.032457061 0.030953852 0.029521303 0.028156597 #>  [73] 0.026856198 0.025617453 0.024436951 0.023311968 0.022239959 0.021218396 #>  [79] 0.020244868 0.019317084 0.018434681 0.017591864 0.016788545 0.016022838 #>  [85] 0.015292949 0.014597168 0.013933868 0.013301503 0.012698600 0.012123756 #>  [91] 0.011575636 0.011052971 0.010554551 0.010079221 0.009625886 0.009193506 #>  [97] 0.008781088 0.008387688 0.008012409 0.007654395 0.007312832 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"Calculates membership probability progression free state, particular time (vectorized), given partitioned survival model given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"","code":"prob_pf_psm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include progression-free survival (PFS). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being progression free in partitioned survival model — prob_pf_psm","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pf_psm(0:100, params) #>   [1] 1.00000000 0.93912025 0.88389518 0.83206183 0.78346757 0.73798093 #>   [7] 0.69544066 0.65566985 0.61849121 0.58377788 0.55141951 0.52128082 #>  [13] 0.49321595 0.46707777 0.44272330 0.42001660 0.39883020 0.37904566 #>  [19] 0.36055364 0.34325356 0.32705314 0.31186789 0.29762051 0.28424030 #>  [25] 0.27166258 0.25982824 0.24868313 0.23817770 0.22826654 0.21890800 #>  [31] 0.21006386 0.20169901 0.19378114 0.18628054 0.17916982 0.17242372 #>  [37] 0.16601894 0.15993392 0.15414874 0.14864495 0.14340545 0.13841439 #>  [43] 0.13365703 0.12911971 0.12478968 0.12065511 0.11670495 0.11292892 #>  [49] 0.10931741 0.10586144 0.10255257 0.09938282 0.09634476 0.09343144 #>  [55] 0.09063634 0.08795338 0.08537683 0.08290135 0.08052190 0.07823376 #>  [61] 0.07603249 0.07391392 0.07187411 0.06990935 0.06801615 0.06619121 #>  [67] 0.06443143 0.06273386 0.06109573 0.05951441 0.05798741 0.05651238 #>  [73] 0.05508709 0.05370942 0.05237738 0.05108905 0.04984263 0.04863641 #>  [79] 0.04746875 0.04633811 0.04524300 0.04418203 0.04315386 0.04215722 #>  [85] 0.04119089 0.04025371 0.03934458 0.03846245 0.03760632 0.03677522 #>  [91] 0.03596824 0.03518449 0.03442315 0.03368341 0.03296451 0.03226570 #>  [97] 0.03158630 0.03092561 0.03028301 0.02965787 0.02904960 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"Calculates membership probability progression free state, particular time (vectorized), given either state transition model (clock forward clock reset) given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"","code":"prob_pf_stm(time, dpam, starting = c(1, 0, 0))"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"time Time (numeric vectorized) dpam List survival regressions model endpoints. must include pre-progression death (PPD) time progression (TTP). starting Vector membership probabilities (PF, PD, death) time zero.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pf_stm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of being progression free in either state transition model (clock forward or clock reset) — prob_pf_stm","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pf_stm(0:100, params) #>   [1] 1.000000000 0.936816026 0.881385907 0.830447785 0.783127984 0.738967456 #>   [7] 0.697648951 0.658927085 0.622647253 0.588690906 0.556920232 0.527190295 #>  [13] 0.499354983 0.473274361 0.448817539 0.425863288 0.404299985 0.384025196 #>  [19] 0.364945100 0.346973830 0.330032807 0.314050098 0.298959805 0.284701505 #>  [25] 0.271219725 0.258462919 0.246382941 0.234935706 0.224080833 0.213781255 #>  [31] 0.204002873 0.194714251 0.185886357 0.177492325 0.169507255 0.161908026 #>  [37] 0.154673141 0.147782578 0.141217667 0.134960971 0.128996189 0.123308057 #>  [43] 0.117882272 0.112705414 0.107764877 0.103048810 0.098546060 0.094246124 #>  [49] 0.090139098 0.086215640 0.082466945 0.078884713 0.075461087 0.072188631 #>  [55] 0.069060301 0.066069417 0.063209645 0.060474974 0.057859696 0.055358390 #>  [61] 0.052965904 0.050677338 0.048488033 0.046393554 0.044389680 0.042472393 #>  [67] 0.040637862 0.038882440 0.037202649 0.035595173 0.034056849 0.032584661 #>  [73] 0.031175728 0.029827304 0.028536765 0.027301606 0.026119435 0.024987966 #>  [79] 0.023905015 0.022868496 0.021876415 0.020926865 0.020018024 0.019148149 #>  [85] 0.018315572 0.017518701 0.016756010 0.016026041 0.015327399 0.014658747 #>  [91] 0.014018808 0.013406359 0.012820230 0.012259301 0.011722498 0.011208797 #>  [97] 0.010717213 0.010246806 0.009796674 0.009365957 0.008953827 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"Calculates probability post progression survival given time progression (vectorized). probability state transition clock forward model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"","code":"prob_pps_cf(ttptimes, ppstimes, dpam)"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"ttptimes Time (numeric vectorized) progression - time baseline. ppstimes Time (numeric vectorized) progression dpam List survival regressions model endpoints. must include post progression survival calculated clock forward state transition model.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"Vector mean probabilities post-progression survival PPS time, averaged TTP times.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of post progression survival under the state transition clock forward model — prob_pps_cf","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pps_cf(0:100, 0:100, params) #>   [1] 1.0000000000 0.9269277329 0.8595239740 0.7969376513 0.7387652556 #>   [6] 0.6846798786 0.6343928456 0.5876418128 0.5441853505 0.5037998452 #>  [11] 0.4662774338 0.4314244718 0.3990603131 0.3690162875 0.3411348163 #>  [16] 0.3152686285 0.2912800553 0.2690403877 0.2484292861 0.2293342129 #>  [21] 0.2116498123 0.1952774482 0.1801248358 0.1661056875 0.1531393715 #>  [26] 0.1411505858 0.1300690452 0.1198291833 0.1103698686 0.1016341336 #>  [31] 0.0935689188 0.0861248289 0.0792559018 0.0729193903 0.0670755557 #>  [36] 0.0616874726 0.0567208450 0.0521438326 0.0479268878 0.0440426013 #>  [41] 0.0404655582 0.0371722017 0.0341407061 0.0313508565 0.0287839376 #>  [46] 0.0264226280 0.0242509024 0.0222539395 0.0204180363 0.0187305277 #>  [51] 0.0171797114 0.0157547788 0.0144457490 0.0132434086 0.0121392552 #>  [56] 0.0111254450 0.0101947448 0.0093404857 0.0085565206 0.0078371848 #>  [61] 0.0071772589 0.0065719348 0.0060167848 0.0055077315 0.0050410215 #>  [66] 0.0046132003 0.0042210887 0.0038617618 0.0035325292 0.0032309164 #>  [71] 0.0029546483 0.0027016332 0.0024699484 0.0022578272 0.0020636461 #>  [76] 0.0018859137 0.0017232603 0.0015744280 0.0014382617 0.0013137012 #>  [81] 0.0011997733 0.0010955850 0.0010003168 0.0009132171 0.0008335964 #>  [86] 0.0007608223 0.0006943151 0.0006335432 0.0005780195 0.0005272975 #>  [91] 0.0004809679 0.0004386560 0.0004000183 0.0003647404 0.0003325341 #>  [96] 0.0003031359 0.0002763042 0.0002518181 0.0002294753 0.0002090907 #> [101] 0.0001904951 # }"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"Calculates probability post progression survival given time progression (vectorized). probability state transition clock reset model, according given statistical distributions parameters.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"","code":"prob_pps_cr(time, dpam)"},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"time Time (numeric vectorized) baseline - time progression. dpam List survival regressions model endpoints. must include post progression survival calculated clock reset state transition model.","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"Numeric value","code":""},{"path":"https://merck.github.io/psm3mkv/reference/prob_pps_cr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate probability of post progression survival under the state transition clock reset model — prob_pps_cr","text":"","code":"# \\donttest{ bosonc <- create_dummydata(\"flexbosms\") fits <- fit_ends_mods_spl(bosonc) # Pick out best distribution according to min AIC params <- list(   ppd = find_bestfit(fits$ppd, \"aic\")$fit,   ttp = find_bestfit(fits$ttp, \"aic\")$fit,   pfs = find_bestfit(fits$pfs, \"aic\")$fit,   os = find_bestfit(fits$os, \"aic\")$fit,   pps_cf = find_bestfit(fits$pps_cf, \"aic\")$fit,   pps_cr = find_bestfit(fits$pps_cr, \"aic\")$fit ) prob_pps_cr(0:100, params) #>   [1] 1.000000000 0.987105716 0.934461106 0.868401686 0.806475394 0.753434376 #>   [7] 0.708946460 0.669965664 0.634136012 0.600110241 0.567138271 0.534824586 #>  [13] 0.502988745 0.471688904 0.441242337 0.411907557 0.383860425 0.357212477 #>  [19] 0.332025219 0.308321522 0.286094792 0.265316380 0.245941526 0.227914131 #>  [25] 0.211170533 0.195642481 0.181259439 0.167950356 0.155644991 0.144274888 #>  [31] 0.133774071 0.124079519 0.115131461 0.106873544 0.099252896 0.092220108 #>  [37] 0.085729164 0.079737331 0.074205016 0.069095609 0.064375317 0.060012987 #>  [43] 0.055979934 0.052249773 0.048798245 0.045602808 0.042642502 0.039898200 #>  [49] 0.037352466 0.034989399 0.032794482 0.030754457 0.028857209 0.027091656 #>  [55] 0.025447658 0.023915928 0.022487958 0.021155944 0.019912726 0.018751730 #>  [61] 0.017666915 0.016652728 0.015704061 0.014816209 0.013984840 0.013205960 #>  [67] 0.012475887 0.011791221 0.011148823 0.010545793 0.009979448 0.009447308 #>  [73] 0.008947078 0.008476629 0.008033991 0.007617337 0.007224971 0.006855320 #>  [79] 0.006506923 0.006178421 0.005868551 0.005576140 0.005300095 0.005039397 #>  [85] 0.004793098 0.004560316 0.004340227 0.004132060 0.003935100 0.003748675 #>  [91] 0.003572161 0.003404972 0.003246561 0.003096416 0.002954059 0.002819042 #>  [97] 0.002690943 0.002569370 0.002453954 0.002344348 0.002240229 # }"},{"path":"https://merck.github.io/psm3mkv/reference/psm3mkv-package.html","id":null,"dir":"Reference","previous_headings":"","what":"psm3mkv: Evaluate Partitioned Survival and State Transition Models — psm3mkv-package","title":"psm3mkv: Evaluate Partitioned Survival and State Transition Models — psm3mkv-package","text":"Fits evaluates three-state partitioned survival analyses (PartSAs) Markov models (clock forward clock reset) progression overall survival data typically collected oncology clinical trials. model structures typically considered cost-effectiveness modeling advanced/metastatic cancer indications. Muston (2024). \"Informing structural assumptions three state oncology cost-effectiveness models model efficiency fit\". Applied Health Economics Health Policy.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/psm3mkv-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"psm3mkv: Evaluate Partitioned Survival and State Transition Models — psm3mkv-package","text":"Maintainer: Dominic Muston dominic.muston@merck.com (ORCID) contributors: Merck & Co., Inc., Rahway, NJ, USA affiliates [copyright holder, funder]","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":null,"dir":"Reference","previous_headings":"","what":"VLOOKUP function — vlookup","title":"VLOOKUP function — vlookup","text":"Function lookup values according index. Aims behave similarly VLOOKUP Microsoft Excel, however several lookups can made (indexval can vector) interpolation available lookups inexact (choice 4 methods).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VLOOKUP function — vlookup","text":"","code":"vlookup(indexval, indexvec, valvec, method = \"geom\")"},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VLOOKUP function — vlookup","text":"indexval index value looked-(may vector multiple values) indexvec vector indices look-within valvec vector values corresponding vector indices method Method may floor, ceiling, arith geom (default).","code":""},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"VLOOKUP function — vlookup","text":"Numeric value vector, depending lookup/interpolation method chosen: floor: Floor (minimum) value, interpolation required measured values ceiling: Ceiling (maximum) value, interpolation required measured values arith: Arithmetic mean, interpolation required measured values geom: Geometric mean, interpolation required measured values","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/reference/vlookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"VLOOKUP function — vlookup","text":"","code":"# Suppose we have survival probabilities at times 0 to 20 times <- 0:20 survival <- 1-times*0.04 # We would like to look-up the survival probability at time 7 vlookup(7, times, survival) #> [1] 0.72 # In this case, the floor, ceiling, arith and geom values are identical # because survival time 7 is known, and no interpolation is necessary vlookup(c(7, 7.5), times, survival) #> [1] 0.7200000 0.6997142 # The second row of the returned tibble reveal different estimates of the survival at time 7.5. # The values vary according to the interpolation method between # observed survival values at times 7 and 8."},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-032-7-june-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.3.2 (7 June 2024)","title":"psm3mkv 0.3.2 (7 June 2024)","text":"CRAN release: 2024-06-07 Revised calculations constrained restricted mean durations internal function calc_drmd() accompanying vignette(\"background-mortality\"). Add new data option: create_dummydata(\"pharmaonc\") provides dataset based pharmaverseadam::adsl() pharmaverseadam::adrs_onco(). requires dependency admiral pharmaverseadam packages. Provide convenience function, compare_psm_likes(), compare total log-likelihood values patient-level dataset fitting PSM-simple PSM-complex models combination endpoint distributions. Add citation publication Applied Health Economics Health Policy, DOI: 10.1007/s40258-024-00884-2. Updated license statements 2024","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-031-7-may-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.3.1 (7 May 2024)","title":"psm3mkv 0.3.1 (7 May 2024)","text":"CRAN release: 2024-05-07 Submission CRAN, including changes requested CRAN","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-030-5-may-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.3.0 (5 May 2024)","title":"psm3mkv 0.3.0 (5 May 2024)","text":"First submission CRAN, accepted","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-022-4-may-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.2.2 (4 May 2024)","title":"psm3mkv 0.2.2 (4 May 2024)","text":"Several minor changes ready package CRAN. Reduced exported functions necessary. Reviewed updated documentation vignettes. Reworked calc_surv() calc_haz() functions calls make efficient use flexsurv objects. Switched logo corporate teal. Fix R CMD check notes.","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-021-14-apr-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.2.1 (14 Apr 2024)","title":"psm3mkv 0.2.1 (14 Apr 2024)","text":"Constraining calculations restricted mean durations accompanying vignette(\"background-mortality\") reworked. calculations using integral/continuous methods reliable. Instead, calc_allrmds() now rmdmethod=\"disc\" option allow discretized calculations given timestep (defaulting one week). new collection functions discrmd.R provide , well constrain_survprob() function, constrains vector survival estimates given times underlying hazard least great accompanying lifetable.","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-020-26-jan-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.2.0 (26 Jan 2024)","title":"psm3mkv 0.2.0 (26 Jan 2024)","text":"version provides additional functionality calculation restricted mean durations calc_allrmds. estimates may now constrained lifetable (see calc_ltsurv) discounting may now applied. vignette describing use functionality provided: vignette(\"background-mortality\"). also changes _pkgdown.yml avoid theming changes imposed 0.6.0 release bslib 0.6.0, thanks @nanxstats.","code":""},{"path":[]},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"added-psm-analysis-functions-experimental-0-1-1","dir":"Changelog","previous_headings":"","what":"Added PSM analysis functions (experimental)","title":"psm3mkv 0.1.1 (5 Jan 2024)","text":"Merged experimental functions main branch following version 0.1 release package. functions provide analyses constraints mortality hazards therefore survival implied PSM. : calc_haz_psm(), calc_surv_psmpps(), pickout_psmhaz, graph_psm_hazards(), graph_psm_survs().","code":""},{"path":"https://merck.github.io/psm3mkv/news/index.html","id":"psm3mkv-010-1-jan-2024","dir":"Changelog","previous_headings":"","what":"psm3mkv 0.1.0 (1 Jan 2024)","title":"psm3mkv 0.1.0 (1 Jan 2024)","text":"initial release package, rather belatedly. code dates October 2023.","code":""}]
